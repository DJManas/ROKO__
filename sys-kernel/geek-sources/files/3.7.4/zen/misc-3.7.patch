diff -urN linux-3.7/arch/x86/kernel/acpi/boot.c zen-misc-12095/arch/x86/kernel/acpi/boot.c
--- linux-3.7/arch/x86/kernel/acpi/boot.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/arch/x86/kernel/acpi/boot.c	2013-01-21 13:11:04.428226353 +0200
@@ -1423,6 +1423,42 @@
 		     DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		     },
 	 },
+	/* ThinkPad Edge 11 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "254523U"),
+		    },
+	},
+	/* ThinkPad Edge 13 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "022120U"),
+		    },
+	},
+	/* ThinkPad Edge 14 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "019923U"),
+		    },
+	},
+	/* ThinkPad Edge 15 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "030222U"),
+		    },
+	},
 	{}
 };
 
diff -urN linux-3.7/arch/x86/kernel/apic/io_apic.c zen-misc-12095/arch/x86/kernel/apic/io_apic.c
--- linux-3.7/arch/x86/kernel/apic/io_apic.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/arch/x86/kernel/apic/io_apic.c	2013-01-21 13:11:04.144229903 +0200
@@ -3639,6 +3639,11 @@
 {
 	int ioapic, pin, idx;
 
+#ifdef CONFIG_ACPI
+	if (acpi_irq_model != ACPI_IRQ_MODEL_IOAPIC)
+		return -1;
+#endif
+
 	if (skip_ioapic_setup)
 		return -1;
 
diff -urN linux-3.7/arch/x86/kernel/cpu/intel.c zen-misc-12095/arch/x86/kernel/cpu/intel.c
--- linux-3.7/arch/x86/kernel/cpu/intel.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/arch/x86/kernel/cpu/intel.c	2013-01-21 13:11:04.286228128 +0200
@@ -30,6 +30,7 @@
 static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 {
 	u64 misc_enable;
+	bool allow_fast_string = true;
 
 	/* Unmask CPUID levels if masked: */
 	if (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {
@@ -120,10 +121,11 @@
 	 * (model 2) with the same problem.
 	 */
 	if (c->x86 == 15) {
-		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+		allow_fast_string = false;
 
+		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
 		if (misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING) {
-			printk(KERN_INFO "kmemcheck: Disabling fast string operations\n");
+			printk_once(KERN_INFO "kmemcheck: Disabling fast string operations\n");
 
 			misc_enable &= ~MSR_IA32_MISC_ENABLE_FAST_STRING;
 			wrmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
@@ -132,13 +134,29 @@
 #endif
 
 	/*
-	 * If fast string is not enabled in IA32_MISC_ENABLE for any reason,
-	 * clear the fast string and enhanced fast string CPU capabilities.
+	 * If BIOS didn't enable fast string operation, try to enable
+	 * it ourselves.  If that fails, then clear the fast string
+	 * and enhanced fast string CPU capabilities.
 	 */
 	if (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {
 		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+
+		if (allow_fast_string &&
+		    !(misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)) {
+			misc_enable |= MSR_IA32_MISC_ENABLE_FAST_STRING;
+			wrmsr_safe(MSR_IA32_MISC_ENABLE, (u32)misc_enable,
+				   (u32)(misc_enable >> 32));
+
+			/* Re-read to make sure it stuck. */
+			rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+
+			if (misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)
+				printk_once(KERN_INFO FW_WARN "IA32_MISC_ENABLE.FAST_STRING_ENABLE was not set\n");
+		}
+
 		if (!(misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)) {
-			printk(KERN_INFO "Disabled fast string operations\n");
+			if (allow_fast_string)
+				printk_once(KERN_INFO "Failed to enable fast string operations\n");
 			setup_clear_cpu_cap(X86_FEATURE_REP_GOOD);
 			setup_clear_cpu_cap(X86_FEATURE_ERMS);
 		}
@@ -474,6 +492,29 @@
 			wrmsrl(MSR_IA32_ENERGY_PERF_BIAS, epb);
 		}
 	}
+
+	/* Enable monitor/mwait if BIOS didn't do it for us. */
+	if (!cpu_has(c, X86_FEATURE_MWAIT) && cpu_has(c, X86_FEATURE_XMM3)
+	    && c->x86 >= 6 && !(c->x86 == 6 && c->x86_model < 0x1c)
+	    && !(c->x86 == 0xf && c->x86_model < 3)) {
+		u64 misc_enable;
+		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+		misc_enable |= MSR_IA32_MISC_ENABLE_MWAIT;
+
+		/*
+		 * Some non-SSE3 cpus will #GP.  We check for that,
+		 * but it can't hurt to be safe.
+		 */
+		wrmsr_safe(MSR_IA32_MISC_ENABLE, (u32)misc_enable,
+			   (u32)(misc_enable >> 32));
+
+		/* Re-read monitor capability. */
+		if (cpuid_ecx(1) & 0x8) {
+			set_cpu_cap(c, X86_FEATURE_MWAIT);
+
+			printk(KERN_WARNING FW_WARN "IA32_MISC_ENABLE.ENABLE_MONITOR_FSM was not set\n");
+		}
+	}
 }
 
 #ifdef CONFIG_X86_32
diff -urN linux-3.7/drivers/acpi/video.c zen-misc-12095/drivers/acpi/video.c
--- linux-3.7/drivers/acpi/video.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/acpi/video.c	2013-01-21 13:09:56.111080435 +0200
@@ -567,8 +567,14 @@
 	video->dos_setting = arg0.integer.value;
 	status = acpi_evaluate_object(video->device->handle, "_DOS",
 		&args, NULL);
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	if (ACPI_FAILURE(status)) {
+		/*
+		 * some platforms don't have _DOS, but the ACPI
+		 * backlight control still works
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No _DOS\n"));
+		return 0;
+	}
 
 	return 0;
 }
diff -urN linux-3.7/drivers/gpu/drm/drm_mm.c zen-misc-12095/drivers/gpu/drm/drm_mm.c
--- linux-3.7/drivers/gpu/drm/drm_mm.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/gpu/drm/drm_mm.c	2013-01-21 13:10:58.195304275 +0200
@@ -213,11 +213,13 @@
 
 	BUG_ON(!hole_node->hole_follows || node->allocated);
 
-	if (mm->color_adjust)
-		mm->color_adjust(hole_node, color, &adj_start, &adj_end);
-
 	if (adj_start < start)
 		adj_start = start;
+	if (adj_end > end)
+		adj_end = end;
+
+	if (mm->color_adjust)
+		mm->color_adjust(hole_node, color, &adj_start, &adj_end);
 
 	if (alignment) {
 		unsigned tmp = adj_start % alignment;
@@ -489,7 +491,7 @@
 	mm->scan_size = size;
 	mm->scanned_blocks = 0;
 	mm->scan_hit_start = 0;
-	mm->scan_hit_size = 0;
+	mm->scan_hit_end = 0;
 	mm->scan_check_range = 0;
 	mm->prev_scanned_node = NULL;
 }
@@ -516,7 +518,7 @@
 	mm->scan_size = size;
 	mm->scanned_blocks = 0;
 	mm->scan_hit_start = 0;
-	mm->scan_hit_size = 0;
+	mm->scan_hit_end = 0;
 	mm->scan_start = start;
 	mm->scan_end = end;
 	mm->scan_check_range = 1;
@@ -535,8 +537,7 @@
 	struct drm_mm *mm = node->mm;
 	struct drm_mm_node *prev_node;
 	unsigned long hole_start, hole_end;
-	unsigned long adj_start;
-	unsigned long adj_end;
+	unsigned long adj_start, adj_end;
 
 	mm->scanned_blocks++;
 
@@ -553,14 +554,8 @@
 	node->node_list.next = &mm->prev_scanned_node->node_list;
 	mm->prev_scanned_node = node;
 
-	hole_start = drm_mm_hole_node_start(prev_node);
-	hole_end = drm_mm_hole_node_end(prev_node);
-
-	adj_start = hole_start;
-	adj_end = hole_end;
-
-	if (mm->color_adjust)
-		mm->color_adjust(prev_node, mm->scan_color, &adj_start, &adj_end);
+	adj_start = hole_start = drm_mm_hole_node_start(prev_node);
+	adj_end = hole_end = drm_mm_hole_node_end(prev_node);
 
 	if (mm->scan_check_range) {
 		if (adj_start < mm->scan_start)
@@ -569,11 +564,14 @@
 			adj_end = mm->scan_end;
 	}
 
+	if (mm->color_adjust)
+		mm->color_adjust(prev_node, mm->scan_color,
+				 &adj_start, &adj_end);
+
 	if (check_free_hole(adj_start, adj_end,
 			    mm->scan_size, mm->scan_alignment)) {
 		mm->scan_hit_start = hole_start;
-		mm->scan_hit_size = hole_end;
-
+		mm->scan_hit_end = hole_end;
 		return 1;
 	}
 
@@ -609,19 +607,10 @@
 			       node_list);
 
 	prev_node->hole_follows = node->scanned_preceeds_hole;
-	INIT_LIST_HEAD(&node->node_list);
 	list_add(&node->node_list, &prev_node->node_list);
 
-	/* Only need to check for containement because start&size for the
-	 * complete resulting free block (not just the desired part) is
-	 * stored. */
-	if (node->start >= mm->scan_hit_start &&
-	    node->start + node->size
-	    		<= mm->scan_hit_start + mm->scan_hit_size) {
-		return 1;
-	}
-
-	return 0;
+	 return (drm_mm_hole_node_end(node) > mm->scan_hit_start &&
+		 node->start < mm->scan_hit_end);
 }
 EXPORT_SYMBOL(drm_mm_scan_remove_block);
 
diff -urN linux-3.7/drivers/input/mouse/synaptics.c zen-misc-12095/drivers/input/mouse/synaptics.c
--- linux-3.7/drivers/input/mouse/synaptics.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/input/mouse/synaptics.c	2013-01-21 13:11:01.237266245 +0200
@@ -1293,7 +1293,9 @@
 		/* Clickpads report only left button */
 		__clear_bit(BTN_RIGHT, dev->keybit);
 		__clear_bit(BTN_MIDDLE, dev->keybit);
-	}
+	} else if (SYN_CAP_CLICKPAD2BTN(priv->ext_cap_0c) ||
+		   SYN_CAP_CLICKPAD2BTN2(priv->ext_cap_0c))
+		__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);
 }
 
 static ssize_t synaptics_show_disable_gesture(struct psmouse *psmouse,
diff -urN linux-3.7/drivers/input/mouse/synaptics.h zen-misc-12095/drivers/input/mouse/synaptics.h
--- linux-3.7/drivers/input/mouse/synaptics.h	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/input/mouse/synaptics.h	2013-01-21 13:11:01.288265608 +0200
@@ -81,6 +81,7 @@
  */
 #define SYN_CAP_CLICKPAD(ex0c)		((ex0c) & 0x100000) /* 1-button ClickPad */
 #define SYN_CAP_CLICKPAD2BTN(ex0c)	((ex0c) & 0x000100) /* 2-button ClickPad */
+#define SYN_CAP_CLICKPAD2BTN2(ex0c)	((ex0c) & 0x200000) /* 2-button ClickPad */
 #define SYN_CAP_MAX_DIMENSIONS(ex0c)	((ex0c) & 0x020000)
 #define SYN_CAP_MIN_DIMENSIONS(ex0c)	((ex0c) & 0x002000)
 #define SYN_CAP_ADV_GESTURE(ex0c)	((ex0c) & 0x080000)
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap_ap.c zen-misc-12095/drivers/net/wireless/hostap/hostap_ap.c
--- linux-3.7/drivers/net/wireless/hostap/hostap_ap.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap_ap.c	2013-01-21 13:10:56.100330466 +0200
@@ -2340,13 +2340,13 @@
 		addr[count].sa_family = ARPHRD_ETHER;
 		memcpy(addr[count].sa_data, sta->addr, ETH_ALEN);
 		if (sta->last_rx_silence == 0)
-			qual[count].qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+                        qual[count].qual = (sta->last_rx_signal - 156) == 0 ?
+                                0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			qual[count].qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		qual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		qual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        qual[count].qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                qual[count].level = sta->last_rx_signal;
+                qual[count].noise = sta->last_rx_silence;
 		qual[count].updated = sta->last_rx_updated;
 
 		sta->last_rx_updated = IW_QUAL_DBM;
@@ -2412,13 +2412,13 @@
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVQUAL;
 		if (sta->last_rx_silence == 0)
-			iwe.u.qual.qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+	                iwe.u.qual.qual = (sta->last_rx_signal -156) == 0 ?
+	                        0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			iwe.u.qual.qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		iwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		iwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        iwe.u.qual.qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                iwe.u.qual.level = sta->last_rx_signal;
+                iwe.u.qual.noise = sta->last_rx_silence;
 		iwe.u.qual.updated = sta->last_rx_updated;
 		iwe.len = IW_EV_QUAL_LEN;
 		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap_config.h zen-misc-12095/drivers/net/wireless/hostap/hostap_config.h
--- linux-3.7/drivers/net/wireless/hostap/hostap_config.h	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap_config.h	2013-01-21 13:10:56.184329416 +0200
@@ -45,4 +45,9 @@
  */
 /* #define PRISM2_NO_STATION_MODES */
 
+/* Enable TX power Setting functions
+ * (min att = -128 , max att =  127)
+ */
+#define RAW_TXPOWER_SETTING
+
 #endif /* HOSTAP_CONFIG_H */
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap.h zen-misc-12095/drivers/net/wireless/hostap/hostap.h
--- linux-3.7/drivers/net/wireless/hostap/hostap.h	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap.h	2013-01-21 13:10:56.194329291 +0200
@@ -90,6 +90,7 @@
 extern const struct ethtool_ops prism2_ethtool_ops;
 
 int hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+int hostap_restore_power(struct net_device *dev);
 
 
 #endif /* HOSTAP_H */
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap_hw.c zen-misc-12095/drivers/net/wireless/hostap/hostap_hw.c
--- linux-3.7/drivers/net/wireless/hostap/hostap_hw.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap_hw.c	2013-01-21 13:10:56.235328778 +0200
@@ -928,6 +928,7 @@
 			prism2_hw_reset(dev);
 	}
 
+	hostap_restore_power(dev);
 	return res;
 }
 
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap_info.c zen-misc-12095/drivers/net/wireless/hostap/hostap_info.c
--- linux-3.7/drivers/net/wireless/hostap/hostap_info.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap_info.c	2013-01-21 13:10:56.083330678 +0200
@@ -435,6 +435,11 @@
 	}
 
 	/* Get BSSID if we have a valid AP address */
+
+	if ( val == HFA384X_LINKSTATUS_CONNECTED ||
+	     val == HFA384X_LINKSTATUS_DISCONNECTED )
+			hostap_restore_power(local->dev);
+
 	if (connected) {
 		netif_carrier_on(local->dev);
 		netif_carrier_on(local->ddev);
diff -urN linux-3.7/drivers/net/wireless/hostap/hostap_ioctl.c zen-misc-12095/drivers/net/wireless/hostap/hostap_ioctl.c
--- linux-3.7/drivers/net/wireless/hostap/hostap_ioctl.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/hostap/hostap_ioctl.c	2013-01-21 13:10:56.173329553 +0200
@@ -1479,23 +1479,20 @@
 		val = 255;
 
 	tmp = val;
-	tmp >>= 2;
 
-	return -12 - tmp;
+	return tmp;
 }
 
 static u16 prism2_txpower_dBm_to_hfa386x(int val)
 {
 	signed char tmp;
 
-	if (val > 20)
-		return 128;
-	else if (val < -43)
+	if (val > 127)
 		return 127;
+	else if (val < -128)
+		return 128;
 
 	tmp = val;
-	tmp = -12 - tmp;
-	tmp <<= 2;
 
 	return (unsigned char) tmp;
 }
@@ -4052,3 +4049,35 @@
 
 	return ret;
 }
+
+/* BUG FIX: Restore power setting value when lost due to F/W bug */
+
+int hostap_restore_power(struct net_device *dev)
+{
+        struct hostap_interface *iface = netdev_priv(dev);
+       local_info_t *local = iface->local;
+
+       u16 val;
+       int ret = 0;
+
+       if (local->txpower_type == PRISM2_TXPOWER_OFF) {
+                       val = 0xff; /* use all standby and sleep modes */
+                       ret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                                              HFA386X_CR_A_D_TEST_MODES2,
+                                              &val, NULL);
+       }
+
+#ifdef RAW_TXPOWER_SETTING
+       if (local->txpower_type == PRISM2_TXPOWER_FIXED) {
+               val = HFA384X_TEST_CFG_BIT_ALC;
+               local->func->cmd(dev, HFA384X_CMDCODE_TEST |
+                                (HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);
+               val = prism2_txpower_dBm_to_hfa386x(local->txpower);
+               ret = (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                            HFA386X_CR_MANUAL_TX_POWER, &val, NULL));
+       }
+#endif /* RAW_TXPOWER_SETTING */
+       return (ret ? -EOPNOTSUPP : 0);
+}
+
+EXPORT_SYMBOL(hostap_restore_power);
diff -urN linux-3.7/drivers/net/wireless/iwlwifi/dvm/tx.c zen-misc-12095/drivers/net/wireless/iwlwifi/dvm/tx.c
--- linux-3.7/drivers/net/wireless/iwlwifi/dvm/tx.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/net/wireless/iwlwifi/dvm/tx.c	2013-01-21 13:10:56.363327178 +0200
@@ -1080,6 +1080,8 @@
 {
 	u16  status = le16_to_cpu(tx_resp->status.status);
 
+	info->flags &= ~IEEE80211_TX_CTL_AMPDU;
+
 	info->status.rates[0].count = tx_resp->failure_frame + 1;
 	if (is_agg)
 		info->flags &= ~IEEE80211_TX_CTL_AMPDU;
diff -urN linux-3.7/drivers/pnp/pnpacpi/core.c zen-misc-12095/drivers/pnp/pnpacpi/core.c
--- linux-3.7/drivers/pnp/pnpacpi/core.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/drivers/pnp/pnpacpi/core.c	2013-01-21 13:08:47.425939117 +0200
@@ -95,6 +95,9 @@
 		return -ENODEV;
 	}
 
+	if (WARN_ON_ONCE(acpi_dev != dev->data))
+		dev->data = acpi_dev;
+
 	ret = pnpacpi_build_resource_template(dev, &buffer);
 	if (ret)
 		return ret;
diff -urN linux-3.7/include/drm/drm_mm.h zen-misc-12095/include/drm/drm_mm.h
--- linux-3.7/include/drm/drm_mm.h	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/include/drm/drm_mm.h	2013-01-21 13:17:02.235753143 +0200
@@ -70,7 +70,7 @@
 	unsigned long scan_color;
 	unsigned long scan_size;
 	unsigned long scan_hit_start;
-	unsigned scan_hit_size;
+	unsigned long scan_hit_end;
 	unsigned scanned_blocks;
 	unsigned long scan_start;
 	unsigned long scan_end;
diff -urN linux-3.7/kernel/watchdog.c zen-misc-12095/kernel/watchdog.c
--- linux-3.7/kernel/watchdog.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/kernel/watchdog.c	2013-01-21 13:12:29.556162107 +0200
@@ -343,6 +343,10 @@
 {
 	struct hrtimer *hrtimer = &__raw_get_cpu_var(watchdog_hrtimer);
 
+	/* kick off the timer for the hardlockup detector */
+	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer->function = watchdog_timer_fn;
+
 	if (!watchdog_enabled) {
 		kthread_park(current);
 		return;
@@ -351,10 +355,6 @@
 	/* Enable the perf event */
 	watchdog_nmi_enable(cpu);
 
-	/* kick off the timer for the hardlockup detector */
-	hrtimer_init(hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	hrtimer->function = watchdog_timer_fn;
-
 	/* done here because hrtimer_start can only pin to smp_processor_id() */
 	hrtimer_start(hrtimer, ns_to_ktime(get_sample_period()),
 		      HRTIMER_MODE_REL_PINNED);
@@ -368,9 +368,6 @@
 {
 	struct hrtimer *hrtimer = &__raw_get_cpu_var(watchdog_hrtimer);
 
-	if (!watchdog_enabled)
-		return;
-
 	watchdog_set_prio(SCHED_NORMAL, 0);
 	hrtimer_cancel(hrtimer);
 	/* disable the perf event */
diff -urN linux-3.7/sound/pci/hda/hda_intel.c zen-misc-12095/sound/pci/hda/hda_intel.c
--- linux-3.7/sound/pci/hda/hda_intel.c	2012-12-11 05:30:57.000000000 +0200
+++ zen-misc-12095/sound/pci/hda/hda_intel.c	2013-01-21 13:12:27.181191798 +0200
@@ -2557,10 +2557,6 @@
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip = card->private_data;
 
-	if (!power_save_controller ||
-	    !(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
-		return -EAGAIN;
-
 	azx_stop_chip(chip);
 	azx_clear_irq_pending(chip);
 	return 0;
@@ -2575,12 +2571,25 @@
 	azx_init_chip(chip, 1);
 	return 0;
 }
+
+static int azx_runtime_idle(struct device *dev)
+{
+	struct snd_card *card = dev_get_drvdata(dev);
+	struct azx *chip = card->private_data;
+
+	if (!power_save_controller ||
+	    !(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
+		return -EBUSY;
+
+	return 0;
+}
+
 #endif /* CONFIG_PM_RUNTIME */
 
 #ifdef CONFIG_PM
 static const struct dev_pm_ops azx_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
-	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, NULL)
+	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
 };
 
 #define AZX_PM_OPS	&azx_pm
