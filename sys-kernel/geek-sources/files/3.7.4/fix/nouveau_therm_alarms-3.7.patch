From 8c8ba895ba73636aa957be3bfce3cb23686a4d0d Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@labri.fr>
Date: Mon, 5 Nov 2012 00:18:49 +0100
Subject: [PATCH] drm/nouveau/therm: implement support for alarms

Needs more testing for nv50->d9. Needs to be implemented on nv43:50.
---
 drivers/gpu/drm/nouveau/core/subdev/therm/base.c |    8 ++
 drivers/gpu/drm/nouveau/core/subdev/therm/nv40.c |   73 +++++++++++-
 drivers/gpu/drm/nouveau/core/subdev/therm/nv50.c |  146 ++++++++++++++++++++++
 drivers/gpu/drm/nouveau/core/subdev/therm/priv.h |   35 +++++
 drivers/gpu/drm/nouveau/core/subdev/therm/temp.c |   43 +++++++
 5 files changed, 304 insertions(+), 1 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/base.c b/drivers/gpu/drm/nouveau/core/subdev/therm/base.c
index f63d78e..81b892d 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/base.c
@@ -88,27 +88,35 @@ nouveau_therm_attr_set(struct nouveau_therm *therm,
 		return nouveau_therm_fan_set_mode(therm, value);
 	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST:
 		priv->bios_sensor.thrs_fan_boost.temp = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_FAN_BOOST_HYST:
 		priv->bios_sensor.thrs_fan_boost.hysteresis = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK:
 		priv->bios_sensor.thrs_down_clock.temp = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_DOWN_CLK_HYST:
 		priv->bios_sensor.thrs_down_clock.hysteresis = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_CRITICAL:
 		priv->bios_sensor.thrs_critical.temp = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_CRITICAL_HYST:
 		priv->bios_sensor.thrs_critical.hysteresis = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN:
 		priv->bios_sensor.thrs_shutdown.temp = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	case NOUVEAU_THERM_ATTR_THRS_SHUTDOWN_HYST:
 		priv->bios_sensor.thrs_shutdown.hysteresis = value;
+		priv->sensor.program_alarms(therm);
 		return 0;
 	}
 
diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/nv40.c b/drivers/gpu/drm/nouveau/core/subdev/therm/nv40.c
index fcf2cfe..c69413b 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/nv40.c
@@ -34,6 +34,7 @@ nv40_sensor_setup(struct nouveau_therm *therm)
 	if (device->chipset >= 0x46) {
 		nv_mask(therm, 0x15b8, 0x80000000, 0);
 		nv_wr32(therm, 0x15b0, 0x80003fff);
+		mdelay(10); /* wait for the temperature to stabilize */
 		return nv_rd32(therm, 0x15b4) & 0x3fff;
 	} else {
 		nv_wr32(therm, 0x15b0, 0xff);
@@ -41,6 +42,7 @@ nv40_sensor_setup(struct nouveau_therm *therm)
 	}
 }
 
+
 static int
 nv40_temp_get(struct nouveau_therm *therm)
 {
@@ -75,6 +77,57 @@ nv40_temp_get(struct nouveau_therm *therm)
 	return core_temp;
 }
 
+static int16_t
+nv40_temp_to_IR(struct nouveau_therm *therm, int16_t temp)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	struct nouveau_device *device = nv_device(therm);
+	int16_t ret = 0;
+
+	ret = temp + 8 - sensor->offset_constant;
+	ret -= sensor->offset_num / sensor->offset_den;
+	ret *= sensor->slope_div / sensor->slope_mult;
+
+	if (device->chipset >= 0x46)
+		return ret & 0x3fff;
+	else
+		return ret & 0xff;
+}
+
+static void
+nv40_temp_program_alarms(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	struct nouveau_device *device = nv_device(therm);
+	int16_t alarm, alarm_min, shutdown;
+	volatile int temp;
+
+	/* force a temperature reading to init the HW */
+	temp = nv40_temp_get(therm);
+
+	/* calculate the thresholds */
+	alarm_min = nv40_temp_to_IR(therm, sensor->thrs_critical.temp -
+					      sensor->thrs_critical.hysteresis);
+	alarm = nv40_temp_to_IR(therm, sensor->thrs_critical.temp);
+	shutdown = nv40_temp_to_IR(therm, sensor->thrs_shutdown.temp);
+
+	/* When the temperature goes higher than $alarm, the card should be
+	 * paused. It will be unpaused when temperature drops below $alarm_min.
+	 * If temperature goes higher than $shutdown, the system should be
+	 * shutdown completely.
+	 */
+	if (device->chipset >= 0x46) {
+		nv_mask(therm, 0x15b0, 0x3fff, shutdown);
+		nv_wr32(therm, 0x15bc, (alarm << 16) | alarm_min);
+
+	} else {
+		nv_mask(therm, 0x15b0, 0xff, shutdown);
+		nv_wr32(therm, 0x15bc, (alarm << 8) | alarm_min);
+	}
+}
+
 int
 nv40_fan_pwm_get(struct nouveau_therm *therm, int line, u32 *divs, u32 *duty)
 {
@@ -118,6 +171,20 @@ nv40_fan_pwm_set(struct nouveau_therm *therm, int line, u32 divs, u32 duty)
 	return 0;
 }
 
+static void
+nv40_temp_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_therm *therm = nouveau_therm(subdev);
+	uint32_t stat = nv_rd32(therm, 0x1100);
+
+	/* traitement */
+
+	/* ack all IRQs */
+	nv_wr32(therm, 0x1100, 0x70000);
+
+	nv_error(therm, "THERM received an IRQ: stat = %x\n", stat);
+}
+
 static int
 nv40_therm_ctor(struct nouveau_object *parent,
 		   struct nouveau_object *engine,
@@ -138,9 +205,13 @@ nv40_therm_ctor(struct nouveau_object *parent,
 	nouveau_therm_sensor_ctor(therm);
 	nouveau_therm_fan_ctor(therm);
 
+	nv40_temp_program_alarms(therm);
+
 	priv->fan.pwm_get = nv40_fan_pwm_get;
 	priv->fan.pwm_set = nv40_fan_pwm_set;
+	priv->sensor.program_alarms = nv40_temp_program_alarms;
 
+	nv_subdev(priv)->intr = nv40_temp_intr;
 	therm->temp_get = nv40_temp_get;
 	therm->fan_get = nouveau_therm_fan_user_get;
 	therm->fan_set = nouveau_therm_fan_user_set;
@@ -160,4 +231,4 @@ nv40_therm_oclass = {
 		.init = nouveau_therm_init,
 		.fini = nouveau_therm_fini,
 	},
-};
\ No newline at end of file
+};
diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/nv50.c b/drivers/gpu/drm/nouveau/core/subdev/therm/nv50.c
index 9360ddd..3e65c0c 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/nv50.c
@@ -111,6 +111,146 @@ nv50_temp_get(struct nouveau_therm *therm)
 	return nv_rd32(therm, 0x20400);
 }
 
+static void
+nv50_temp_program_alarms(struct nouveau_therm *therm)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->sensor.alarm_program_lock, flags);
+
+	/* enable RISING and FALLING IRQs for shutdown, THRS 0, 1, 2 and 4 */
+	nv_wr32(therm, 0x20100, 0xffffffff);
+	nv_wr32(therm, 0x20000, 0x3f3);
+	nv_wr32(therm, 0x20134, 0xffffffff); /* nva3+ only, short circuit it! */
+
+	/* shutdown: The computer should be shutdown when reached */
+	nv_wr32(therm, 0x20484, sensor->thrs_shutdown.hysteresis);
+	nv_wr32(therm, 0x20480, sensor->thrs_shutdown.temp);
+	nouveau_therm_sensor_set_threshold_state(therm,
+						 NOUVEAU_THERM_THRS_SHUTDOWN,
+						 NOUVEAU_THERM_THRS_LOWER);
+
+	/* THRS_1 : fan boost*/
+	nv_wr32(therm, 0x204c4, sensor->thrs_fan_boost.temp);
+	nouveau_therm_sensor_set_threshold_state(therm,
+						 NOUVEAU_THERM_THRS_FANBOOST,
+						 NOUVEAU_THERM_THRS_LOWER);
+
+	/* THRS_2 : critical */
+	nv_wr32(therm, 0x204c0, sensor->thrs_critical.temp);
+	nouveau_therm_sensor_set_threshold_state(therm,
+						 NOUVEAU_THERM_THRS_CRITICAL,
+						 NOUVEAU_THERM_THRS_LOWER);
+
+	/* THRS_4 : down clock */
+	nv_wr32(therm, 0x20414, sensor->thrs_down_clock.temp);
+	nouveau_therm_sensor_set_threshold_state(therm,
+						 NOUVEAU_THERM_THRS_DOWNCLOCK,
+						 NOUVEAU_THERM_THRS_LOWER);
+
+	spin_unlock_irqrestore(&priv->sensor.alarm_program_lock, flags);
+
+	nv_info(therm,
+		"programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\n",
+		sensor->thrs_fan_boost.temp, sensor->thrs_fan_boost.hysteresis,
+		sensor->thrs_down_clock.temp,
+		sensor->thrs_down_clock.hysteresis,
+		sensor->thrs_critical.temp, sensor->thrs_critical.hysteresis,
+		sensor->thrs_shutdown.temp, sensor->thrs_shutdown.hysteresis);
+
+	/* TODO: check the themperature to see if we hit a threshold ! */
+
+}
+
+/* must be called with alarm_program_lock taken ! */
+static void
+nv50_temp_threshold_hyst_emulation(struct nouveau_therm *therm,
+				   uint32_t thrs_reg, u8 status_bit,
+				   const struct nvbios_therm_threshold *thrs,
+				   enum nouveau_therm_thrs thrs_name)
+{
+	enum nouveau_therm_thrs_direction direction;
+	enum nouveau_therm_thrs_state prev_state, new_state;
+	int /*rising,*/ temp;
+
+	prev_state = nouveau_therm_sensor_get_threshold_state(therm, thrs_name);
+	temp = nv_rd32(therm, thrs_reg);
+	if (temp == thrs->temp)
+		nv_wr32(therm, thrs_reg, thrs->temp - thrs->hysteresis);
+	else
+		nv_wr32(therm, thrs_reg, thrs->temp);
+
+	if (temp == thrs->temp && prev_state == NOUVEAU_THERM_THRS_LOWER) {
+		direction = NOUVEAU_THERM_THRS_RISING;
+		new_state = NOUVEAU_THERM_THRS_HIGHER;
+	} else if (temp == thrs->temp - thrs->hysteresis &&
+			prev_state == NOUVEAU_THERM_THRS_HIGHER) {
+		direction = NOUVEAU_THERM_THRS_FALLING;
+		new_state = NOUVEAU_THERM_THRS_LOWER;
+	} else /* we are in a strange state, do nothing */
+		return;
+
+	nouveau_therm_sensor_set_threshold_state(therm, thrs_name, new_state);
+	nouveau_therm_sensor_event(therm, thrs_name, direction);
+}
+
+static void
+nv50_temp_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_therm *therm = nouveau_therm(subdev);
+	struct nouveau_therm_priv *priv = (void *)therm;
+	struct nvbios_therm_sensor *sensor = &priv->bios_sensor;
+	unsigned long flags;
+	uint32_t intr;
+
+	spin_lock_irqsave(&priv->sensor.alarm_program_lock, flags);
+
+	intr = nv_rd32(therm, 0x20100);
+
+	/* THRS_4: downclock */
+	if (intr & 0x002) {
+		nv50_temp_threshold_hyst_emulation(therm, 0x20414, 24,
+						  &sensor->thrs_down_clock,
+						  NOUVEAU_THERM_THRS_DOWNCLOCK);
+		intr &= ~0x002;
+	}
+
+	/* shutdown */
+	if (intr & 0x004) {
+		nv50_temp_threshold_hyst_emulation(therm, 0x20480, 20,
+						   &sensor->thrs_shutdown,
+						   NOUVEAU_THERM_THRS_SHUTDOWN);
+		intr &= ~0x004;
+	}
+
+	/* THRS_1 : fan boost */
+	if (intr & 0x008) {
+		nv50_temp_threshold_hyst_emulation(therm, 0x204c4, 21,
+						   &sensor->thrs_fan_boost,
+						   NOUVEAU_THERM_THRS_FANBOOST);
+		intr &= ~0x008;
+	}
+
+	/* THRS_2 : critical */
+	if (intr & 0x010) {
+		nv50_temp_threshold_hyst_emulation(therm, 0x204c0, 22,
+						   &sensor->thrs_critical,
+						   NOUVEAU_THERM_THRS_CRITICAL);
+		intr &= ~0x010;
+	}
+
+	if (intr)
+		nv_error(therm, "unhandled intr 0x%08x\n", intr);
+
+	/* ACK everything */
+	nv_wr32(therm, 0x20100, 0xffffffff);
+	nv_wr32(therm, 0x1100, 0x10000); /* PBUS */
+
+	spin_unlock_irqrestore(&priv->sensor.alarm_program_lock, flags);
+}
+
 static int
 nv50_therm_ctor(struct nouveau_object *parent,
 		   struct nouveau_object *engine,
@@ -127,14 +267,20 @@ nv50_therm_ctor(struct nouveau_object *parent,
 	if (ret)
 		return ret;
 
+	spin_lock_init(&priv->sensor.alarm_program_lock);
+
 	nouveau_therm_ic_ctor(therm);
 	nouveau_therm_sensor_ctor(therm);
 	nouveau_therm_fan_ctor(therm);
 
+	nv50_temp_program_alarms(therm);
+
 	priv->fan.pwm_get = nv50_fan_pwm_get;
 	priv->fan.pwm_set = nv50_fan_pwm_set;
 	priv->fan.pwm_clock = nv50_fan_pwm_clock;
+	priv->sensor.program_alarms = nv50_temp_program_alarms;
 
+	nv_subdev(priv)->intr = nv50_temp_intr;
 	therm->temp_get = nv50_temp_get;
 	therm->fan_get = nouveau_therm_fan_user_get;
 	therm->fan_set = nouveau_therm_fan_user_set;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/priv.h b/drivers/gpu/drm/nouveau/core/subdev/therm/priv.h
index fc04406..1b881c3 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/priv.h
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/priv.h
@@ -29,6 +29,24 @@
 #include <subdev/bios/therm.h>
 #include <subdev/timer.h>
 
+enum nouveau_therm_thrs_direction {
+	NOUVEAU_THERM_THRS_FALLING = 0,
+	NOUVEAU_THERM_THRS_RISING = 1
+};
+
+enum nouveau_therm_thrs_state {
+	NOUVEAU_THERM_THRS_LOWER = 0,
+	NOUVEAU_THERM_THRS_HIGHER = 1
+};
+
+enum nouveau_therm_thrs {
+	NOUVEAU_THERM_THRS_FANBOOST = 0,
+	NOUVEAU_THERM_THRS_DOWNCLOCK = 1,
+	NOUVEAU_THERM_THRS_CRITICAL = 2,
+	NOUVEAU_THERM_THRS_SHUTDOWN = 3,
+	NOUVEAU_THERM_THRS_NR
+};
+
 struct nouveau_therm_priv {
 	struct nouveau_therm base;
 
@@ -57,6 +75,13 @@ struct nouveau_therm_priv {
 		int (*pwm_clock)(struct nouveau_therm *);
 	} fan;
 
+	/* alarms priv */
+	struct {
+		spinlock_t alarm_program_lock;
+		enum nouveau_therm_thrs_state alarm_state[NOUVEAU_THERM_THRS_NR];
+		void (*program_alarms)(struct nouveau_therm *);
+	} sensor;
+
 	/* ic */
 	struct i2c_client *ic;
 };
@@ -82,3 +107,13 @@ int nouveau_therm_fan_set_mode(struct nouveau_therm *therm,
 
 
 int nouveau_therm_fan_sense(struct nouveau_therm *therm);
+
+void nouveau_therm_sensor_set_threshold_state(struct nouveau_therm *therm,
+					     enum nouveau_therm_thrs thrs,
+					     enum nouveau_therm_thrs_state st);
+enum nouveau_therm_thrs_state
+nouveau_therm_sensor_get_threshold_state(struct nouveau_therm *therm,
+					 enum nouveau_therm_thrs thrs);
+void nouveau_therm_sensor_event(struct nouveau_therm *therm,
+			        enum nouveau_therm_thrs thrs,
+			        enum nouveau_therm_thrs_direction dir);
diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/temp.c b/drivers/gpu/drm/nouveau/core/subdev/therm/temp.c
index 2042823..5b8b5f6 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/temp.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/temp.c
@@ -65,6 +65,49 @@ nouveau_therm_temp_safety_checks(struct nouveau_therm *therm)
 		priv->bios_sensor.offset_den = 1;
 }
 
+/* must be called with alarm_program_lock taken ! */
+void nouveau_therm_sensor_set_threshold_state(struct nouveau_therm *therm,
+					     enum nouveau_therm_thrs thrs,
+					     enum nouveau_therm_thrs_state st)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	priv->sensor.alarm_state[thrs] = st;
+}
+
+/* must be called with alarm_program_lock taken ! */
+enum nouveau_therm_thrs_state
+nouveau_therm_sensor_get_threshold_state(struct nouveau_therm *therm,
+					 enum nouveau_therm_thrs thrs)
+{
+	struct nouveau_therm_priv *priv = (void *)therm;
+	return priv->sensor.alarm_state[thrs];
+}
+
+void nouveau_therm_sensor_event(struct nouveau_therm *therm,
+			        enum nouveau_therm_thrs thrs,
+			        enum nouveau_therm_thrs_direction dir)
+{
+	const char *thresolds[] = {
+		"fanboost", "downclock", "critical", "shutdown"
+	};
+
+	if (thrs < 0 || thrs > 3)
+		return;
+
+	if (dir == NOUVEAU_THERM_THRS_FALLING)
+		nv_info(therm, "temperature went bellow the '%s' threshold\n",
+			 thresolds[thrs]);
+	else
+		nv_info(therm, "temperature hit the '%s' threshold\n",
+			 thresolds[thrs]);
+
+	if (thrs == NOUVEAU_THERM_THRS_FANBOOST &&
+		dir == NOUVEAU_THERM_THRS_RISING) {
+		nouveau_therm_fan_set(therm, 100);
+		nouveau_therm_fan_set_mode(therm, FAN_CONTROL_AUTO);
+	}
+}
+
 int
 nouveau_therm_sensor_ctor(struct nouveau_therm *therm)
 {
-- 
1.7.8.6
