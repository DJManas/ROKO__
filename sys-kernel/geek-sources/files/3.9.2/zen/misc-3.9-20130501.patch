diff -x .git -urN linux-3.9/arch/x86/kernel/acpi/boot.c zen/arch/x86/kernel/acpi/boot.c
--- linux-3.9/arch/x86/kernel/acpi/boot.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/arch/x86/kernel/acpi/boot.c	2013-05-01 11:54:33.959054309 +0300
@@ -1432,6 +1432,42 @@
 		     DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		     },
 	 },
+	/* ThinkPad Edge 11 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "254523U"),
+		    },
+	},
+	/* ThinkPad Edge 13 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "022120U"),
+		    },
+	},
+	/* ThinkPad Edge 14 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "019923U"),
+		    },
+	},
+	/* ThinkPad Edge 15 (AMD) */
+	{
+	 .callback = dmi_ignore_irq0_timer_override,
+	 .ident = "ThinkPad Edge",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "030222U"),
+		    },
+	},
 	{}
 };
 
diff -x .git -urN linux-3.9/arch/x86/kernel/apic/io_apic.c zen/arch/x86/kernel/apic/io_apic.c
--- linux-3.9/arch/x86/kernel/apic/io_apic.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/arch/x86/kernel/apic/io_apic.c	2013-05-01 11:54:33.962054272 +0300
@@ -3572,6 +3572,11 @@
 {
 	int ioapic, pin, idx;
 
+#ifdef CONFIG_ACPI
+	if (acpi_irq_model != ACPI_IRQ_MODEL_IOAPIC)
+		return -1;
+#endif
+
 	if (skip_ioapic_setup)
 		return -1;
 
diff -x .git -urN linux-3.9/arch/x86/kernel/cpu/intel.c zen/arch/x86/kernel/cpu/intel.c
--- linux-3.9/arch/x86/kernel/cpu/intel.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/arch/x86/kernel/cpu/intel.c	2013-05-01 11:54:33.964054247 +0300
@@ -29,6 +29,7 @@
 static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 {
 	u64 misc_enable;
+	bool allow_fast_string = true;
 
 	/* Unmask CPUID levels if masked: */
 	if (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {
@@ -119,10 +120,11 @@
 	 * (model 2) with the same problem.
 	 */
 	if (c->x86 == 15) {
-		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+		allow_fast_string = false;
 
+		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
 		if (misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING) {
-			printk(KERN_INFO "kmemcheck: Disabling fast string operations\n");
+			printk_once(KERN_INFO "kmemcheck: Disabling fast string operations\n");
 
 			misc_enable &= ~MSR_IA32_MISC_ENABLE_FAST_STRING;
 			wrmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
@@ -131,13 +133,29 @@
 #endif
 
 	/*
-	 * If fast string is not enabled in IA32_MISC_ENABLE for any reason,
-	 * clear the fast string and enhanced fast string CPU capabilities.
+	 * If BIOS didn't enable fast string operation, try to enable
+	 * it ourselves.  If that fails, then clear the fast string
+	 * and enhanced fast string CPU capabilities.
 	 */
 	if (c->x86 > 6 || (c->x86 == 6 && c->x86_model >= 0xd)) {
 		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+
+		if (allow_fast_string &&
+		    !(misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)) {
+			misc_enable |= MSR_IA32_MISC_ENABLE_FAST_STRING;
+			wrmsr_safe(MSR_IA32_MISC_ENABLE, (u32)misc_enable,
+				   (u32)(misc_enable >> 32));
+
+			/* Re-read to make sure it stuck. */
+			rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+
+			if (misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)
+				printk_once(KERN_INFO FW_WARN "IA32_MISC_ENABLE.FAST_STRING_ENABLE was not set\n");
+		}
+
 		if (!(misc_enable & MSR_IA32_MISC_ENABLE_FAST_STRING)) {
-			printk(KERN_INFO "Disabled fast string operations\n");
+			if (allow_fast_string)
+				printk_once(KERN_INFO "Failed to enable fast string operations\n");
 			setup_clear_cpu_cap(X86_FEATURE_REP_GOOD);
 			setup_clear_cpu_cap(X86_FEATURE_ERMS);
 		}
@@ -473,6 +491,29 @@
 			wrmsrl(MSR_IA32_ENERGY_PERF_BIAS, epb);
 		}
 	}
+
+	/* Enable monitor/mwait if BIOS didn't do it for us. */
+	if (!cpu_has(c, X86_FEATURE_MWAIT) && cpu_has(c, X86_FEATURE_XMM3)
+	    && c->x86 >= 6 && !(c->x86 == 6 && c->x86_model < 0x1c)
+	    && !(c->x86 == 0xf && c->x86_model < 3)) {
+		u64 misc_enable;
+		rdmsrl(MSR_IA32_MISC_ENABLE, misc_enable);
+		misc_enable |= MSR_IA32_MISC_ENABLE_MWAIT;
+
+		/*
+		 * Some non-SSE3 cpus will #GP.  We check for that,
+		 * but it can't hurt to be safe.
+		 */
+		wrmsr_safe(MSR_IA32_MISC_ENABLE, (u32)misc_enable,
+			   (u32)(misc_enable >> 32));
+
+		/* Re-read monitor capability. */
+		if (cpuid_ecx(1) & 0x8) {
+			set_cpu_cap(c, X86_FEATURE_MWAIT);
+
+			printk(KERN_WARNING FW_WARN "IA32_MISC_ENABLE.ENABLE_MONITOR_FSM was not set\n");
+		}
+	}
 }
 
 #ifdef CONFIG_X86_32
diff -x .git -urN linux-3.9/drivers/acpi/blacklist.c zen/drivers/acpi/blacklist.c
--- linux-3.9/drivers/acpi/blacklist.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/acpi/blacklist.c	2013-05-01 11:54:33.976054097 +0300
@@ -193,6 +193,13 @@
 	return 0;
 }
 
+static int __init dmi_disable_osi_win8(const struct dmi_system_id *d)
+{
+	printk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);
+	acpi_osi_setup("!Windows 2012");
+	return 0;
+}
+
 static struct dmi_system_id acpi_osi_dmi_table[] __initdata = {
 	{
 	.callback = dmi_disable_osi_vista,
@@ -268,6 +275,37 @@
 		},
 	},
 
+	/*
+	 * The following Lenovo models have a broken workaround in the
+	 * acpi_video backlight implementation to meet the Windows 8
+	 * requirement of 101 backlight levels. Reverting to pre-Win8
+	 * behavoir fixes the problem.
+	 */
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad T430",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T430"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad T430s",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad T430s"),
+		},
+	},
+	{
+	.callback = dmi_disable_osi_win8,
+	.ident = "Lenovo ThinkPad X230",
+	.matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+		     DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad X230"),
+		},
+	},
+
 	/*
 	 * BIOS invocation of _OSI(Linux) is almost always a BIOS bug.
 	 * Linux ignores it, except for the machines enumerated below.
diff -x .git -urN linux-3.9/drivers/acpi/video.c zen/drivers/acpi/video.c
--- linux-3.9/drivers/acpi/video.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/acpi/video.c	2013-05-01 11:54:33.979054059 +0300
@@ -581,8 +581,14 @@
 	video->dos_setting = arg0.integer.value;
 	status = acpi_evaluate_object(video->device->handle, "_DOS",
 		&args, NULL);
-	if (ACPI_FAILURE(status))
-		return -EIO;
+	if (ACPI_FAILURE(status)) {
+		/*
+		 * some platforms don't have _DOS, but the ACPI
+		 * backlight control still works
+		 */
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No _DOS\n"));
+		return 0;
+	}
 
 	return 0;
 }
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/evergreen.c zen/drivers/gpu/drm/radeon/evergreen.c
--- linux-3.9/drivers/gpu/drm/radeon/evergreen.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/evergreen.c	2013-05-01 11:54:34.015053609 +0300
@@ -1316,6 +1316,8 @@
 
 	/* disable VGA render */
 	WREG32(VGA_RENDER_CONTROL, 0);
+
+	save->mc_fb_location = (u64)(RREG32(MC_VM_FB_LOCATION) & 0xffff) << 24;
 	/* blank the display controllers */
 	for (i = 0; i < rdev->num_crtc; i++) {
 		crtc_enabled = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]) & EVERGREEN_CRTC_MASTER_EN;
@@ -1340,6 +1342,14 @@
 					WREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);
 				}
 			}
+			save->crtc_mc_paddr[i] =
+				RREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i]);
+			save->crtc_mc_paddr[i] |=
+				(u64)RREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i]) << 32;
+			save->crtc_mc_saddr[i] =
+				RREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i]);
+			save->crtc_mc_saddr[i] |=
+				(u64)RREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i]) << 32;
 			/* wait for the next frame */
 			frame_count = radeon_get_vblank_counter(rdev, i);
 			for (j = 0; j < rdev->usec_timeout; j++) {
@@ -1370,17 +1380,28 @@
 {
 	u32 tmp, frame_count;
 	int i, j;
+	u64 mc_fb_location = (u64)(RREG32(MC_VM_FB_LOCATION) & 0xffff) << 24;
 
 	/* update crtc base addresses */
 	for (i = 0; i < rdev->num_crtc; i++) {
-		WREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],
-		       upper_32_bits(rdev->mc.vram_start));
-		WREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],
-		       upper_32_bits(rdev->mc.vram_start));
-		WREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],
-		       (u32)rdev->mc.vram_start);
-		WREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],
-		       (u32)rdev->mc.vram_start);
+		if (save->crtc_enabled[i] &&
+		    (save->mc_fb_location != mc_fb_location)) {
+			if (save->crtc_mc_paddr[i])
+				save->crtc_mc_paddr[i] -= save->mc_fb_location;
+			save->crtc_mc_paddr[i] += mc_fb_location;
+			if (save->crtc_mc_saddr[i])
+				save->crtc_mc_saddr[i] -= save->mc_fb_location;
+			save->crtc_mc_saddr[i] += mc_fb_location;
+
+			WREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],
+			       upper_32_bits(save->crtc_mc_paddr[i]));
+			WREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],
+			       upper_32_bits(save->crtc_mc_saddr[i]));
+			WREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],
+			       save->crtc_mc_paddr[i]);
+			WREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],
+			       save->crtc_mc_saddr[i]);
+		}
 	}
 	WREG32(EVERGREEN_VGA_MEMORY_BASE_ADDRESS_HIGH, upper_32_bits(rdev->mc.vram_start));
 	WREG32(EVERGREEN_VGA_MEMORY_BASE_ADDRESS, (u32)rdev->mc.vram_start);
@@ -1425,6 +1446,7 @@
 void evergreen_mc_program(struct radeon_device *rdev)
 {
 	struct evergreen_mc_save save;
+	u32 mc_vm_fb_location = RREG32(MC_VM_FB_LOCATION);
 	u32 tmp;
 	int i, j;
 
@@ -1477,7 +1499,8 @@
 	}
 	tmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;
 	tmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);
-	WREG32(MC_VM_FB_LOCATION, tmp);
+	if (tmp != mc_vm_fb_location)
+		WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7) | (1 << 30));
 	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/r600.c zen/drivers/gpu/drm/radeon/r600.c
--- linux-3.9/drivers/gpu/drm/radeon/r600.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/r600.c	2013-05-01 11:54:34.026053472 +0300
@@ -1049,6 +1049,7 @@
 static void r600_mc_program(struct radeon_device *rdev)
 {
 	struct rv515_mc_save save;
+	u32 mc_vm_fb_location = RREG32(MC_VM_FB_LOCATION);
 	u32 tmp;
 	int i, j;
 
@@ -1090,7 +1091,8 @@
 	WREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR, rdev->vram_scratch.gpu_addr >> 12);
 	tmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;
 	tmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);
-	WREG32(MC_VM_FB_LOCATION, tmp);
+	if (tmp != mc_vm_fb_location)
+		WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7));
 	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
@@ -1166,11 +1168,8 @@
 				mc->mc_vram_size >> 20, mc->vram_start,
 				mc->vram_end, mc->real_vram_size >> 20);
 	} else {
-		u64 base = 0;
-		if (rdev->flags & RADEON_IS_IGP) {
-			base = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;
-			base <<= 24;
-		}
+		u64 base = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;
+		base <<= 24;
 		radeon_vram_location(rdev, &rdev->mc, base);
 		rdev->mc.gtt_base_align = 0;
 		radeon_gtt_location(rdev, mc);
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/radeon_asic.h zen/drivers/gpu/drm/radeon/radeon_asic.h
--- linux-3.9/drivers/gpu/drm/radeon/radeon_asic.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/radeon_asic.h	2013-05-01 11:54:34.029053434 +0300
@@ -264,6 +264,9 @@
 	u32 vga_render_control;
 	u32 vga_hdp_control;
 	bool crtc_enabled[2];
+	u64 crtc_mc_paddr[2];
+	u64 crtc_mc_saddr[2];
+	u64 mc_fb_location;
 };
 
 int rv515_init(struct radeon_device *rdev);
@@ -417,6 +420,9 @@
 	u32 vga_render_control;
 	u32 vga_hdp_control;
 	bool crtc_enabled[RADEON_MAX_CRTCS];
+	u64 crtc_mc_paddr[RADEON_MAX_CRTCS];
+	u64 crtc_mc_saddr[RADEON_MAX_CRTCS];
+	u64 mc_fb_location;
 };
 
 void evergreen_pcie_gart_tlb_flush(struct radeon_device *rdev);
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/radeon_device.c zen/drivers/gpu/drm/radeon/radeon_device.c
--- linux-3.9/drivers/gpu/drm/radeon/radeon_device.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/radeon_device.c	2013-05-01 11:54:34.031053409 +0300
@@ -359,7 +359,7 @@
 	uint64_t limit = (uint64_t)radeon_vram_limit << 20;
 
 	mc->vram_start = base;
-	if (mc->mc_vram_size > (0xFFFFFFFF - base + 1)) {
+	if (mc->mc_vram_size > (rdev->mc.mc_mask - base + 1)) {
 		dev_warn(rdev->dev, "limiting VRAM to PCI aperture size\n");
 		mc->real_vram_size = mc->aper_size;
 		mc->mc_vram_size = mc->aper_size;
@@ -394,7 +394,7 @@
 {
 	u64 size_af, size_bf;
 
-	size_af = ((0xFFFFFFFF - mc->vram_end) + mc->gtt_base_align) & ~mc->gtt_base_align;
+	size_af = ((rdev->mc.mc_mask - mc->vram_end) + mc->gtt_base_align) & ~mc->gtt_base_align;
 	size_bf = mc->vram_start & ~mc->gtt_base_align;
 	if (size_bf > size_af) {
 		if (mc->gtt_size > size_bf) {
@@ -1068,6 +1068,17 @@
 		radeon_agp_disable(rdev);
 	}
 
+	/* Set the internal MC address mask
+	 * This is the max address of the GPU's
+	 * internal address space.
+	 */
+	if (rdev->family >= CHIP_CAYMAN)
+		rdev->mc.mc_mask = 0xffffffffffULL; /* 40 bit MC */
+	else if (rdev->family >= CHIP_CEDAR)
+		rdev->mc.mc_mask = 0xfffffffffULL; /* 36 bit MC */
+	else
+		rdev->mc.mc_mask = 0xffffffffULL; /* 32 bit MC */
+
 	/* set DMA mask + need_dma32 flags.
 	 * PCIE - can handle 40-bits.
 	 * IGP - can handle 40-bits
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/radeon.h zen/drivers/gpu/drm/radeon/radeon.h
--- linux-3.9/drivers/gpu/drm/radeon/radeon.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/radeon.h	2013-05-01 11:54:34.029053434 +0300
@@ -517,6 +517,7 @@
 	bool			vram_is_ddr;
 	bool			igp_sideport_enabled;
 	u64                     gtt_base_align;
+	u64                     mc_mask;
 };
 
 bool radeon_combios_sideport_present(struct radeon_device *rdev);
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/rv515.c zen/drivers/gpu/drm/radeon/rv515.c
--- linux-3.9/drivers/gpu/drm/radeon/rv515.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/rv515.c	2013-05-01 11:54:34.034053372 +0300
@@ -293,6 +293,12 @@
 	save->vga_render_control = RREG32(R_000300_VGA_RENDER_CONTROL);
 	save->vga_hdp_control = RREG32(R_000328_VGA_HDP_CONTROL);
 
+	if (rdev->family >= CHIP_RV770)
+		save->mc_fb_location = (u64)(RREG32(0x2024) & 0xffff) << 24;
+	else if (rdev->family >= CHIP_R600)
+		save->mc_fb_location = (u64)(RREG32(0x2180) & 0xffff) << 24;
+	else
+		save->mc_fb_location = 0;
 	/* disable VGA render */
 	WREG32(R_000300_VGA_RENDER_CONTROL, 0);
 	/* blank the display controllers */
@@ -306,6 +312,25 @@
 				tmp |= AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;
 				WREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);
 			}
+			if (rdev->family >= CHIP_R600) {
+				save->crtc_mc_paddr[i] =
+					RREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i]);
+				save->crtc_mc_saddr[i] =
+					RREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i]);
+				if (rdev->family >= CHIP_RV770) {
+					if (i == 0) {
+						save->crtc_mc_paddr[i] |=
+							(u64)RREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH) << 32;
+						save->crtc_mc_saddr[i] |=
+							(u64)RREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH) << 32;
+					} else {
+						save->crtc_mc_paddr[i] |=
+							(u64)RREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH) << 32;
+						save->crtc_mc_saddr[i] |=
+							(u64)RREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH) << 32;
+					}
+				}
+			}
 			/* wait for the next frame */
 			frame_count = radeon_get_vblank_counter(rdev, i);
 			for (j = 0; j < rdev->usec_timeout; j++) {
@@ -344,26 +369,50 @@
 {
 	u32 tmp, frame_count;
 	int i, j;
+	u64 mc_fb_location;
+
+	if (rdev->family >= CHIP_RV770)
+		mc_fb_location = (u64)(RREG32(0x2024) & 0xffff) << 24;
+	else if (rdev->family >= CHIP_R600)
+		mc_fb_location = (u64)(RREG32(0x2180) & 0xffff) << 24;
+	else
+		mc_fb_location = rdev->mc.vram_start;
 
 	/* update crtc base addresses */
 	for (i = 0; i < rdev->num_crtc; i++) {
-		if (rdev->family >= CHIP_RV770) {
-			if (i == 1) {
-				WREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
-				       upper_32_bits(rdev->mc.vram_start));
-				WREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
-				       upper_32_bits(rdev->mc.vram_start));
-			} else {
-				WREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
-				       upper_32_bits(rdev->mc.vram_start));
-				WREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
-				       upper_32_bits(rdev->mc.vram_start));
+		if (rdev->family >= CHIP_R600) {
+			if (save->crtc_enabled[i] &&
+			    (save->mc_fb_location != mc_fb_location)) {
+				if (save->crtc_mc_paddr[i])
+					save->crtc_mc_paddr[i] -= save->mc_fb_location;
+				save->crtc_mc_paddr[i] += mc_fb_location;
+				if (save->crtc_mc_saddr[i])
+					save->crtc_mc_saddr[i] -= save->mc_fb_location;
+				save->crtc_mc_saddr[i] += mc_fb_location;
+				if (rdev->family >= CHIP_RV770) {
+					if (i == 0) {
+						WREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
+						       upper_32_bits(save->crtc_mc_paddr[i]));
+						WREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
+						       upper_32_bits(save->crtc_mc_saddr[i]));
+					} else {
+						WREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,
+						       upper_32_bits(save->crtc_mc_paddr[i]));
+						WREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,
+						       upper_32_bits(save->crtc_mc_saddr[i]));
+					}
+				}
+				WREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],
+				       save->crtc_mc_paddr[i]);
+				WREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],
+				       save->crtc_mc_saddr[i]);
 			}
+		} else {
+			WREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],
+			       rdev->mc.vram_start);
+			WREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],
+			       rdev->mc.vram_start);
 		}
-		WREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],
-		       (u32)rdev->mc.vram_start);
-		WREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],
-		       (u32)rdev->mc.vram_start);
 	}
 	WREG32(R_000310_VGA_MEMORY_BASE_ADDRESS, (u32)rdev->mc.vram_start);
 
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/rv770.c zen/drivers/gpu/drm/radeon/rv770.c
--- linux-3.9/drivers/gpu/drm/radeon/rv770.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/rv770.c	2013-05-01 11:54:34.035053359 +0300
@@ -264,6 +264,7 @@
 static void rv770_mc_program(struct radeon_device *rdev)
 {
 	struct rv515_mc_save save;
+	u32 mc_vm_fb_location = RREG32(MC_VM_FB_LOCATION);
 	u32 tmp;
 	int i, j;
 
@@ -310,7 +311,8 @@
 	WREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR, rdev->vram_scratch.gpu_addr >> 12);
 	tmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;
 	tmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);
-	WREG32(MC_VM_FB_LOCATION, tmp);
+	if (tmp != mc_vm_fb_location)
+		WREG32(MC_VM_FB_LOCATION, tmp);
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7));
 	WREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);
@@ -861,7 +863,9 @@
 				mc->mc_vram_size >> 20, mc->vram_start,
 				mc->vram_end, mc->real_vram_size >> 20);
 	} else {
-		radeon_vram_location(rdev, &rdev->mc, 0);
+		u64 base = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;
+		base <<= 24;
+		radeon_vram_location(rdev, &rdev->mc, base);
 		rdev->mc.gtt_base_align = 0;
 		radeon_gtt_location(rdev, mc);
 	}
diff -x .git -urN linux-3.9/drivers/gpu/drm/radeon/si.c zen/drivers/gpu/drm/radeon/si.c
--- linux-3.9/drivers/gpu/drm/radeon/si.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/gpu/drm/radeon/si.c	2013-05-01 11:54:34.037053334 +0300
@@ -2493,6 +2493,7 @@
 static void si_mc_program(struct radeon_device *rdev)
 {
 	struct evergreen_mc_save save;
+	u32 mc_vm_fb_location = RREG32(MC_VM_FB_LOCATION);
 	u32 tmp;
 	int i, j;
 
@@ -2521,7 +2522,8 @@
 	       rdev->vram_scratch.gpu_addr >> 12);
 	tmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;
 	tmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);
-	WREG32(MC_VM_FB_LOCATION, tmp);
+	if (tmp != mc_vm_fb_location)
+		WREG32(MC_VM_FB_LOCATION, tmp);
 	/* XXX double check these! */
 	WREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));
 	WREG32(HDP_NONSURFACE_INFO, (2 << 7) | (1 << 30));
@@ -2538,58 +2540,20 @@
 	rv515_vga_render_disable(rdev);
 }
 
-/* SI MC address space is 40 bits */
-static void si_vram_location(struct radeon_device *rdev,
-			     struct radeon_mc *mc, u64 base)
-{
-	mc->vram_start = base;
-	if (mc->mc_vram_size > (0xFFFFFFFFFFULL - base + 1)) {
-		dev_warn(rdev->dev, "limiting VRAM to PCI aperture size\n");
-		mc->real_vram_size = mc->aper_size;
-		mc->mc_vram_size = mc->aper_size;
-	}
-	mc->vram_end = mc->vram_start + mc->mc_vram_size - 1;
-	dev_info(rdev->dev, "VRAM: %lluM 0x%016llX - 0x%016llX (%lluM used)\n",
-			mc->mc_vram_size >> 20, mc->vram_start,
-			mc->vram_end, mc->real_vram_size >> 20);
-}
-
-static void si_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc)
-{
-	u64 size_af, size_bf;
-
-	size_af = ((0xFFFFFFFFFFULL - mc->vram_end) + mc->gtt_base_align) & ~mc->gtt_base_align;
-	size_bf = mc->vram_start & ~mc->gtt_base_align;
-	if (size_bf > size_af) {
-		if (mc->gtt_size > size_bf) {
-			dev_warn(rdev->dev, "limiting GTT\n");
-			mc->gtt_size = size_bf;
-		}
-		mc->gtt_start = (mc->vram_start & ~mc->gtt_base_align) - mc->gtt_size;
-	} else {
-		if (mc->gtt_size > size_af) {
-			dev_warn(rdev->dev, "limiting GTT\n");
-			mc->gtt_size = size_af;
-		}
-		mc->gtt_start = (mc->vram_end + 1 + mc->gtt_base_align) & ~mc->gtt_base_align;
-	}
-	mc->gtt_end = mc->gtt_start + mc->gtt_size - 1;
-	dev_info(rdev->dev, "GTT: %lluM 0x%016llX - 0x%016llX\n",
-			mc->gtt_size >> 20, mc->gtt_start, mc->gtt_end);
-}
-
 static void si_vram_gtt_location(struct radeon_device *rdev,
 				 struct radeon_mc *mc)
 {
+	u64 base = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;
+	base <<= 24;
 	if (mc->mc_vram_size > 0xFFC0000000ULL) {
 		/* leave room for at least 1024M GTT */
 		dev_warn(rdev->dev, "limiting VRAM\n");
 		mc->real_vram_size = 0xFFC0000000ULL;
 		mc->mc_vram_size = 0xFFC0000000ULL;
 	}
-	si_vram_location(rdev, &rdev->mc, 0);
+	radeon_vram_location(rdev, &rdev->mc, base);
 	rdev->mc.gtt_base_align = 0;
-	si_gtt_location(rdev, mc);
+	radeon_gtt_location(rdev, mc);
 }
 
 static int si_mc_init(struct radeon_device *rdev)
diff -x .git -urN linux-3.9/drivers/input/mouse/synaptics.c zen/drivers/input/mouse/synaptics.c
--- linux-3.9/drivers/input/mouse/synaptics.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/input/mouse/synaptics.c	2013-05-01 11:54:34.050053172 +0300
@@ -1317,7 +1317,9 @@
 		/* Clickpads report only left button */
 		__clear_bit(BTN_RIGHT, dev->keybit);
 		__clear_bit(BTN_MIDDLE, dev->keybit);
-	}
+	} else if (SYN_CAP_CLICKPAD2BTN(priv->ext_cap_0c) ||
+		   SYN_CAP_CLICKPAD2BTN2(priv->ext_cap_0c))
+		__set_bit(INPUT_PROP_BUTTONPAD, dev->propbit);
 }
 
 static ssize_t synaptics_show_disable_gesture(struct psmouse *psmouse,
diff -x .git -urN linux-3.9/drivers/input/mouse/synaptics.h zen/drivers/input/mouse/synaptics.h
--- linux-3.9/drivers/input/mouse/synaptics.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/input/mouse/synaptics.h	2013-05-01 11:54:34.050053172 +0300
@@ -81,6 +81,7 @@
  */
 #define SYN_CAP_CLICKPAD(ex0c)		((ex0c) & 0x100000) /* 1-button ClickPad */
 #define SYN_CAP_CLICKPAD2BTN(ex0c)	((ex0c) & 0x000100) /* 2-button ClickPad */
+#define SYN_CAP_CLICKPAD2BTN2(ex0c)	((ex0c) & 0x200000) /* 2-button ClickPad */
 #define SYN_CAP_MAX_DIMENSIONS(ex0c)	((ex0c) & 0x020000)
 #define SYN_CAP_MIN_DIMENSIONS(ex0c)	((ex0c) & 0x002000)
 #define SYN_CAP_ADV_GESTURE(ex0c)	((ex0c) & 0x080000)
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap_ap.c zen/drivers/net/wireless/hostap/hostap_ap.c
--- linux-3.9/drivers/net/wireless/hostap/hostap_ap.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap_ap.c	2013-05-01 11:54:34.079052809 +0300
@@ -2340,13 +2340,13 @@
 		addr[count].sa_family = ARPHRD_ETHER;
 		memcpy(addr[count].sa_data, sta->addr, ETH_ALEN);
 		if (sta->last_rx_silence == 0)
-			qual[count].qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+                        qual[count].qual = (sta->last_rx_signal - 156) == 0 ?
+                                0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			qual[count].qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		qual[count].level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		qual[count].noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        qual[count].qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                qual[count].level = sta->last_rx_signal;
+                qual[count].noise = sta->last_rx_silence;
 		qual[count].updated = sta->last_rx_updated;
 
 		sta->last_rx_updated = IW_QUAL_DBM;
@@ -2412,13 +2412,13 @@
 		memset(&iwe, 0, sizeof(iwe));
 		iwe.cmd = IWEVQUAL;
 		if (sta->last_rx_silence == 0)
-			iwe.u.qual.qual = sta->last_rx_signal < 27 ?
-				0 : (sta->last_rx_signal - 27) * 92 / 127;
+	                iwe.u.qual.qual = (sta->last_rx_signal -156) == 0 ?
+	                        0 : (sta->last_rx_signal - 156) * 92 / 64;
 		else
-			iwe.u.qual.qual = sta->last_rx_signal -
-				sta->last_rx_silence - 35;
-		iwe.u.qual.level = HFA384X_LEVEL_TO_dBm(sta->last_rx_signal);
-		iwe.u.qual.noise = HFA384X_LEVEL_TO_dBm(sta->last_rx_silence);
+                        iwe.u.qual.qual = (sta->last_rx_signal -
+                                sta->last_rx_silence) * 92 / 64;
+                iwe.u.qual.level = sta->last_rx_signal;
+                iwe.u.qual.noise = sta->last_rx_silence;
 		iwe.u.qual.updated = sta->last_rx_updated;
 		iwe.len = IW_EV_QUAL_LEN;
 		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap_config.h zen/drivers/net/wireless/hostap/hostap_config.h
--- linux-3.9/drivers/net/wireless/hostap/hostap_config.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap_config.h	2013-05-01 11:54:34.079052809 +0300
@@ -45,4 +45,9 @@
  */
 /* #define PRISM2_NO_STATION_MODES */
 
+/* Enable TX power Setting functions
+ * (min att = -128 , max att =  127)
+ */
+#define RAW_TXPOWER_SETTING
+
 #endif /* HOSTAP_CONFIG_H */
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap.h zen/drivers/net/wireless/hostap/hostap.h
--- linux-3.9/drivers/net/wireless/hostap/hostap.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap.h	2013-05-01 11:54:34.051053159 +0300
@@ -90,6 +90,7 @@
 extern const struct ethtool_ops prism2_ethtool_ops;
 
 int hostap_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+int hostap_restore_power(struct net_device *dev);
 
 
 #endif /* HOSTAP_H */
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap_hw.c zen/drivers/net/wireless/hostap/hostap_hw.c
--- linux-3.9/drivers/net/wireless/hostap/hostap_hw.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap_hw.c	2013-05-01 11:54:34.080052797 +0300
@@ -928,6 +928,7 @@
 			prism2_hw_reset(dev);
 	}
 
+	hostap_restore_power(dev);
 	return res;
 }
 
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap_info.c zen/drivers/net/wireless/hostap/hostap_info.c
--- linux-3.9/drivers/net/wireless/hostap/hostap_info.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap_info.c	2013-05-01 11:54:34.080052797 +0300
@@ -435,6 +435,11 @@
 	}
 
 	/* Get BSSID if we have a valid AP address */
+
+	if ( val == HFA384X_LINKSTATUS_CONNECTED ||
+	     val == HFA384X_LINKSTATUS_DISCONNECTED )
+			hostap_restore_power(local->dev);
+
 	if (connected) {
 		netif_carrier_on(local->dev);
 		netif_carrier_on(local->ddev);
diff -x .git -urN linux-3.9/drivers/net/wireless/hostap/hostap_ioctl.c zen/drivers/net/wireless/hostap/hostap_ioctl.c
--- linux-3.9/drivers/net/wireless/hostap/hostap_ioctl.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/drivers/net/wireless/hostap/hostap_ioctl.c	2013-05-01 11:54:34.082052772 +0300
@@ -1479,23 +1479,20 @@
 		val = 255;
 
 	tmp = val;
-	tmp >>= 2;
 
-	return -12 - tmp;
+	return tmp;
 }
 
 static u16 prism2_txpower_dBm_to_hfa386x(int val)
 {
 	signed char tmp;
 
-	if (val > 20)
-		return 128;
-	else if (val < -43)
+	if (val > 127)
 		return 127;
+	else if (val < -128)
+		return 128;
 
 	tmp = val;
-	tmp = -12 - tmp;
-	tmp <<= 2;
 
 	return (unsigned char) tmp;
 }
@@ -4052,3 +4049,35 @@
 
 	return ret;
 }
+
+/* BUG FIX: Restore power setting value when lost due to F/W bug */
+
+int hostap_restore_power(struct net_device *dev)
+{
+        struct hostap_interface *iface = netdev_priv(dev);
+       local_info_t *local = iface->local;
+
+       u16 val;
+       int ret = 0;
+
+       if (local->txpower_type == PRISM2_TXPOWER_OFF) {
+                       val = 0xff; /* use all standby and sleep modes */
+                       ret = local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                                              HFA386X_CR_A_D_TEST_MODES2,
+                                              &val, NULL);
+       }
+
+#ifdef RAW_TXPOWER_SETTING
+       if (local->txpower_type == PRISM2_TXPOWER_FIXED) {
+               val = HFA384X_TEST_CFG_BIT_ALC;
+               local->func->cmd(dev, HFA384X_CMDCODE_TEST |
+                                (HFA384X_TEST_CFG_BITS << 8), 0, &val, NULL);
+               val = prism2_txpower_dBm_to_hfa386x(local->txpower);
+               ret = (local->func->cmd(dev, HFA384X_CMDCODE_WRITEMIF,
+                            HFA386X_CR_MANUAL_TX_POWER, &val, NULL));
+       }
+#endif /* RAW_TXPOWER_SETTING */
+       return (ret ? -EOPNOTSUPP : 0);
+}
+
+EXPORT_SYMBOL(hostap_restore_power);
diff -x .git -urN linux-3.9/net/ethernet/eth.c zen/net/ethernet/eth.c
--- linux-3.9/net/ethernet/eth.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/net/ethernet/eth.c	2013-05-01 11:54:34.098052572 +0300
@@ -370,7 +370,7 @@
 	dev->hard_header_len 	= ETH_HLEN;
 	dev->mtu		= ETH_DATA_LEN;
 	dev->addr_len		= ETH_ALEN;
-	dev->tx_queue_len	= 1000;	/* Ethernet wants good queues */
+	dev->tx_queue_len	= 50;	/* Ethernet wants good latency.  Use FreeBSD defaults. */
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 	dev->priv_flags		|= IFF_TX_SKB_SHARING;
 
