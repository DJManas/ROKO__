https://bugzilla.kernel.org/show_bug.cgi?id=14733#c83

diff -urN a/drivers/acpi/ec.c b/drivers/acpi/ec.c
--- a/drivers/acpi/ec.c	2013-02-19 01:58:34.000000000 +0200
+++ b/drivers/acpi/ec.c	2013-03-13 00:03:28.392031778 +0200
@@ -234,6 +234,7 @@
 				if (ec_transaction_done(ec))
 					return 0;
 			} else {
+				msleep(1);
 				if (wait_event_timeout(ec->wait,
 						ec_transaction_done(ec),
 						msecs_to_jiffies(1)))
@@ -241,8 +242,8 @@
 			}
 			advance_transaction(ec, acpi_ec_read_status(ec));
 		} while (time_before(jiffies, delay));
-		if (acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF)
-			break;
+//		if (acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF)
+//			break;
 		pr_debug(PREFIX "controller reset, restart transaction\n");
 		spin_lock_irqsave(&ec->lock, flags);
 		start_transaction(ec);
@@ -279,6 +280,15 @@
 	return (status & ACPI_EC_FLAG_IBF) == 0;
 }
 
+/* try to clean input buffer with burst_disable transaction */
+static int acpi_ec_clean_buffer(struct acpi_ec *ec)
+{
+	struct transaction t = {.command = ACPI_EC_BURST_DISABLE,
+				.wdata = NULL, .rdata = NULL,
+				.wlen = 0, .rlen = 0};
+	return acpi_ec_transaction_unlocked(ec, &t);
+}
+
 static int ec_wait_ibf0(struct acpi_ec *ec)
 {
 	unsigned long delay = jiffies + msecs_to_jiffies(ec_delay);
@@ -287,7 +297,8 @@
 		if (wait_event_timeout(ec->wait, ec_check_ibf0(ec),
 					msecs_to_jiffies(1)))
 			return 0;
-	return -ETIME;
+//	return -ETIME;
+	return acpi_ec_clean_buffer(ec);
 }
 
 static int acpi_ec_transaction(struct acpi_ec *ec, struct transaction *t)
