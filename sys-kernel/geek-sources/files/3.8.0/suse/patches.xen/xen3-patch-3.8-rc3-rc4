From: Linux Kernel Mailing List <linux-kernel@vger.kernel.org>
Subject: Linux: 3.8-rc4
Patch-mainline: 3.8-rc4

 This patch contains the differences between 3.8-rc3 and 3.8-rc4.

Automatically created from "tmp/patch-3.8-rc3-rc4" by xen-port-patches.py
Acked-by: jbeulich@suse.com

--- head.orig/arch/x86/kernel/setup-xen.c	2013-01-09 15:32:33.000000000 +0100
+++ head/arch/x86/kernel/setup-xen.c	2013-01-30 12:08:16.000000000 +0100
@@ -680,6 +680,83 @@ static __init void reserve_ibft_region(v
 #ifndef CONFIG_XEN
 static unsigned reserve_low = CONFIG_X86_RESERVE_LOW << 10;
 
+static bool __init snb_gfx_workaround_needed(void)
+{
+#ifdef CONFIG_PCI
+	int i;
+	u16 vendor, devid;
+	static const __initconst u16 snb_ids[] = {
+		0x0102,
+		0x0112,
+		0x0122,
+		0x0106,
+		0x0116,
+		0x0126,
+		0x010a,
+	};
+
+	/* Assume no if something weird is going on with PCI */
+	if (!early_pci_allowed())
+		return false;
+
+	vendor = read_pci_config_16(0, 2, 0, PCI_VENDOR_ID);
+	if (vendor != 0x8086)
+		return false;
+
+	devid = read_pci_config_16(0, 2, 0, PCI_DEVICE_ID);
+	for (i = 0; i < ARRAY_SIZE(snb_ids); i++)
+		if (devid == snb_ids[i])
+			return true;
+#endif
+
+	return false;
+}
+
+/*
+ * Sandy Bridge graphics has trouble with certain ranges, exclude
+ * them from allocation.
+ */
+static void __init trim_snb_memory(void)
+{
+	static const __initconst unsigned long bad_pages[] = {
+		0x20050000,
+		0x20110000,
+		0x20130000,
+		0x20138000,
+		0x40004000,
+	};
+	int i;
+
+	if (!snb_gfx_workaround_needed())
+		return;
+
+	printk(KERN_DEBUG "reserving inaccessible SNB gfx pages\n");
+
+	/*
+	 * Reserve all memory below the 1 MB mark that has not
+	 * already been reserved.
+	 */
+	memblock_reserve(0, 1<<20);
+
+	for (i = 0; i < ARRAY_SIZE(bad_pages); i++) {
+		if (memblock_reserve(bad_pages[i], PAGE_SIZE))
+			printk(KERN_WARNING "failed to reserve 0x%08lx\n",
+			       bad_pages[i]);
+	}
+}
+
+/*
+ * Here we put platform-specific memory range workarounds, i.e.
+ * memory known to be corrupt or otherwise in need to be reserved on
+ * specific platforms.
+ *
+ * If this gets used more widely it could use a real dispatch mechanism.
+ */
+static void __init trim_platform_memory_ranges(void)
+{
+	trim_snb_memory();
+}
+
 static void __init trim_bios_range(void)
 {
 	/*
@@ -700,6 +777,7 @@ static void __init trim_bios_range(void)
 	 * take them out.
 	 */
 	e820_remove_range(BIOS_BEGIN, BIOS_END - BIOS_BEGIN, E820_RAM, 1);
+
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
 }
 
@@ -1032,6 +1110,8 @@ void __init setup_arch(char **cmdline_p)
 
 #ifndef CONFIG_XEN
 	setup_real_mode();
+
+	trim_platform_memory_ranges();
 #endif
 
 	init_gbpages();
--- head.orig/drivers/dma/ioat/dma.h	2013-01-14 13:51:50.000000000 +0100
+++ head/drivers/dma/ioat/dma.h	2013-01-30 12:31:16.000000000 +0100
@@ -332,7 +332,7 @@ static inline void ioat_remove_dca_provi
 	struct ioatdma_device *device = pci_get_drvdata(pdev);
 	BUG_ON(device->dca);
 }
-static inline struct dca_provider *__devinit
+static inline struct dca_provider *
 __ioat_dca_init(struct pci_dev *pdev, void __iomem *iobase)
 {
 	return NULL;
