declare -x ABI="amd64"
declare -x ABI_MIPS=""
declare -x ABI_PPC=""
declare -x ABI_RISCV=""
declare -x ABI_S390=""
declare -x ABI_X86="64 32"
declare -a ALL_AUTOTOOLS_MACROS=([0]="AC_PROG_LIBTOOL" [1]="AM_PROG_LIBTOOL" [2]="LT_INIT" [3]="LT_CONFIG_LTDL_DIR" [4]="AC_CONFIG_HEADERS" [5]="AC_CONFIG_HEADER" [6]="AM_CONFIG_HEADERS" [7]="AM_CONFIG_HEADER" [8]="AC_CONFIG_SUBDIRS" [9]="AC_CONFIG_AUX_DIR" [10]="AC_CONFIG_MACRO_DIR" [11]="AM_INIT_AUTOMAKE" [12]="AM_GLIB_GNU_GETTEXT" [13]="AM_GNU_GETTEXT_VERSION" [14]="AM_GNU_GETTEXT_REQUIRE_VERSION" [15]="AC_PROG_INTLTOOL" [16]="IT_PROG_INTLTOOL" [17]="GTK_DOC_CHECK" [18]="GNOME_DOC_INIT")
declare -- ALL_LOCALES="
aa
af
af_ZA
am
am_ET
ang
ar
ar_AE
ar_BH
ar_DZ
ar_EG
ar_IN
ar_IQ
ar_JO
ar_KW
ar_LB
ar_LY
ar_MA
ar_OM
ar_QA
ar_SA
ar_SD
ar_SY
ar_TN
ar_YE
as
ast
az
az_AZ
az_IR
be
be@latin
be_BY
bg
bg_BG
bn
bn_IN
br
br_FR
bs
bs_BA
byn
ca
ca@valencia
ca_ES
ca_ES@euro
ca_ES@valencia
chs
cht
crh
cs
cs_CZ
cy
cy_GB
cz
da
da_DK
de
de_AT
de_AT@euro
de_BE
de_BE@euro
de_CH
de_DE
de_DE.UTF-8
de_DE@euro
de_LU
de_LU@euro
dk
dv
dz
el
el_GR
el_GR.UTF-8
el_GR@euro
en
en@IPA
en@boldquot
en@quot
en@shaw
en_AU
en_BW
en_CA
en_DK
en_GB
en_GB.UTF-8
en_HK
en_IE
en_IE@euro
en_IN
en_NZ
en_PH
en_RN
en_SG
en_UK
en_US
en_US.UTF-8
en_ZA
en_ZW
eo
eo_EO
es
es_AR
es_BO
es_CL
es_CO
es_CR
es_DO
es_EC
es_ES
es_ES.UTF-8
es_ES@euro
es_GT
es_HN
es_MX
es_NI
es_PA
es_PE
es_PR
es_PY
es_SV
es_US
es_UY
es_VE
et
et_EE
eu
eu_ES
eu_ES@euro
fa
fa_IR
fa_IR.UTF-8
fi
fi_FI
fi_FI@euro
fo
fo_FO
fr
fr_BE
fr_BE@euro
fr_CA
fr_CH
fr_FR
fr_FR.UTF-8
fr_FR@euro
fr_LU
fr_LU@euro
fur
fy
ga
ga_IE
ga_IE@euro
gd
gd_GB
gez
gl
gl_ES
gl_ES@euro
gr
gu
gv
gv_GB
haw
he
he_IL
hi
hi_IN
hi_IN.UTF-8
hr
hr_HR
hu
hu_HU
hy
hy_AM
ia
id
id_ID
is
is_IS
it
it_CH
it_IT
it_IT@euro
iu
iw
iw_IL
ja
ja_JP
ja_JP.EUC
ja_JP.EUC-JP
ja_JP.UTF-8
ja_JP.eucJP
ka
ka_GE
kk
kl
kl_GL
km
km_KH
kn
ko
ko_KR
ko_KR.EUC-KR
ko_KR.UTF-8
kok
ku
kw
kw_GB
ky
la
lg
li
lo
lt
lt_LT
lv
lv_LV
mai
mg
mhr
mi
mi_NZ
mk
mk_MK
ml
mn
mr
mr_IN
mr_IN.UTF-8
ms
ms_MY
mt
mt_MT
my
my_MM
nb
nb_NO
nds
ne
nl
nl_BE
nl_BE@euro
nl_NL
nl_NL@euro
nn
nn_NO
no
no_NO
nso
nyc
oc
oc_FR
om
or
pa
pl
pl_PL
ps
pt
pt_BR
pt_PT
pt_PT@euro
rm
ro
ro_RO
ru
ru_RU
ru_RU.KOI8-R
ru_RU.UTF-8
ru_UA
rw
sa
si
sid
sk
sk_SK
sl
sl_SI
so
sp
sq
sq_AL
sr
sr@Latn
sr@ije
sr@latin
sr_RS
sr_YU
sr_YU@cyrillic
sv
sv_FI
sv_FI@euro
sv_SE
sw
syr
ta
ta_IN
te
te_IN
tg
tg_TJ
th
th_TH
ti
ti_ER
ti_ET
tig
tk
tl
tl_PH
tr
tr_TR
tt
tt_RU
ug
uk
uk_UA
ur
ur_PK
uz
uz@Latn
uz_UZ
ve
vi
vi_VN
vi_VN.UTF-8
wa
wal
wo
xh
yi
yi_US
zh
zh_CN
zh_CN.GB18030
zh_CN.GB2312
zh_CN.GBK
zh_CN.UTF-8
zh_HK
zh_HK.UTF-8
zh_SG
zh_TW
zh_TW.Big5
zh_TW.EUC-TW
zh_TW.UTF-8
zu
"
declare -x ALSA_CARDS=""
declare -x APACHE2_MODULES=""
declare -x APACHE2_MPMS=""
declare -x ARCH="amd64"
declare -- AT_M4DIR=""
declare -- AT_SYS_M4DIR=""
declare -- AUTOTOOLS_AUTO_DEPEND="no"
declare -- AUTOTOOLS_BUILD_DIR="/portage/tmp/portage/media-libs/glu-9.0.0-r1/work/glu-9.0.0-abi_x86_64.amd64"
declare -- AUTOTOOLS_DEPEND="!<sys-devel/gettext-0.18.1.1-r3
	|| ( >=sys-devel/automake-1.16.1:1.16 >=sys-devel/automake-1.15.1:1.15  )
	>=sys-devel/autoconf-2.69
	>=sys-devel/libtool-2.4"
declare BDEPEND=""
declare -x BOOTSTRAP_USE="unicode internal-glib pkg-config split-usr python_targets_python3_6 python_targets_python2_7 multilib systemd udev"
declare -x CALLIGRA_FEATURES=""
declare -x CAMERAS=""
declare -x CBUILD="x86_64-pc-linux-gnu"
declare -x CFLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu"
declare -x CFLAGS_amd64="-m64"
declare -x CFLAGS_default
declare -x CFLAGS_x32="-mx32"
declare -x CFLAGS_x86="-m32"
declare -x CHOST="x86_64-pc-linux-gnu"
declare -x CHOST_amd64="x86_64-pc-linux-gnu"
declare -x CHOST_default="x86_64-pc-linux-gnu"
declare -x CHOST_x32="x86_64-pc-linux-gnux32"
declare -x CHOST_x86="i686-pc-linux-gnu"
declare -x CINNAMON="-gnome -nautilus gtk -cups -bluetooth -cdr -tracker -games -qt5 -kde networkmanager thunar"
declare -x CINNAMON_VERSION="4.0.3"
declare -x COLLECTD_PLUGINS=""
declare -x COMMON_FLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe"
declare -x CONF_PREFIX="/usr"
declare -x CPU_FLAGS_ARM=""
declare -x CPU_FLAGS_X86=""
declare -x CTARGET_default="x86_64-pc-linux-gnu"
declare -x CURL_SSL=""
declare -x CXXFLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu"
declare -x DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/1000/bus"
declare -x DEFAULT_ABI="amd64"
declare -x DEFINED_PHASES=" compile configure install prepare test"
declare DEPEND=">=virtual/opengl-7.0-r1[abi_x86_32(-)?,abi_x86_64(-)?,abi_x86_x32(-)?,abi_mips_n32(-)?,abi_mips_n64(-)?,abi_mips_o32(-)?,abi_riscv_lp64d(-)?,abi_riscv_lp64(-)?,abi_s390_32(-)?,abi_s390_64(-)?] >=app-portage/elt-patches-20170815"
declare DESCRIPTION="The OpenGL Utility Library"
declare -x DESKTOP_SESSION="cinnamon"
declare -x DESTTREE="/usr"
declare -x DEVIRTLTO="-fdevirtualize-at-ltrans"
declare -x DIRHISTORY_SIZE="30"
declare -x DIROPTIONS="-m0755"
declare -x EAPI="5"
declare -x EBEEP_IGNORE="1"
declare -- ECONF_SOURCE="/portage/tmp/portage/media-libs/glu-9.0.0-r1/work/glu-9.0.0"
declare -- EGIT_REPO_URI="https://gitlab.freedesktop.org/mesa/glu.git"
declare -x ELIBC="glibc"
declare -x ENLIGHTENMENT_MODULES=""
declare -x ENV_UNSET="DBUS_SESSION_BUS_ADDRESS DISPLAY GOBIN PERL5LIB PERL5OPT PERLPREFIX PERL_CORE PERL_MB_OPT PERL_MM_OPT XAUTHORITY XDG_CACHE_HOME XDG_CONFIG_HOME XDG_DATA_HOME XDG_RUNTIME_DIR"
declare -- EPATCH_COMMON_OPTS="-g0 -E --no-backup-if-mismatch"
declare -- EPATCH_EXCLUDE=""
declare -- EPATCH_FORCE="no"
declare -- EPATCH_MULTI_MSG="Applying various patches (bugfixes/updates) ..."
declare -- EPATCH_OPTS=""
declare -- EPATCH_SINGLE_MSG=""
declare -- EPATCH_SOURCE="/portage/tmp/portage/media-libs/glu-9.0.0-r1/work/patch"
declare -- EPATCH_SUFFIX="patch.bz2"
declare -- EPATCH_USER_SOURCE="/etc/portage/patches"
declare -x EPAUSE_IGNORE="1"
declare -- EPOCHREALTIME="1562590009,425391"
declare -- EPOCHSECONDS="1562590009"
declare -x EXEOPTIONS="-m0755"
declare -x F77FLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu"
declare -- F77LAGS=""
declare -x FCFLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu"
declare -- FCLAGS=""
declare -x FETCHCOMMAND_SSH="bash -c \"x=\\\${2#ssh://} ; host=\\\${x%%/*} ; port=\\\${host##*:} ; host=\\\${host%:*} ; [[ \\\${host} = \\\${port} ]] && port= ; exec rsync --rsh=\\\"ssh \\\${port:+-p\\\${port}} \\\${3}\\\" -avP \\\"\\\${host}:/\\\${x#*/}\\\" \\\"\\\$1\\\"\" rsync \"\${DISTDIR}/\${FILE}\" \"\${URI}\" \"\${PORTAGE_SSH_OPTS}\""
declare -x FFLAGS="-march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe -Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu"
declare -x FFTOOLS=""
declare -a FLAG_FILTER_CFLAGS=()
declare -a FLAG_FILTER_CXXFLAGS=()
declare -a FLAG_FILTER_CXX_FORTRAN=([0]="-std=c1*" [1]="-std=c8*" [2]="-std=c9*" [3]="-std=gnu1*" [4]="-std=gnu8*" [5]="-std=gnu9*" [6]="-std=iso*")
declare -a FLAG_FILTER_C_CXX=([0]="-fall-intrinsics" [1]="-fbackslash" [2]="-fcray-pointer" [3]="-fd-lines-as-*" [4]="-fdec*" [5]="-fdefault-*" [6]="-fdollar-ok" [7]="-ffixed-*" [8]="-ffree-*" [9]="-fimplicit-none" [10]="-finteger-4-integer-8" [11]="-fmax-identifier-length*" [12]="-fmodule-private" [13]="-fno-range-check" [14]="-freal-*" [15]="-ftest-forall-temp" [16]="-std=f*" [17]="-std=gnu" [18]="-std=legacy")
declare -a FLAG_FILTER_C_FORTRAN=([0]="-fabi-*" [1]="-faligned-new" [2]="-fcheck-new" [3]="-fconcepts" [4]="-fconstexpr-*" [5]="-fdeduce-init-list" [6]="-fext*" [7]="-ffor-scope" [8]="-ffriend-injection" [9]="-fms-extensions" [10]="-fnew-inheriting-ctors" [11]="-fnew-ttp-matching" [12]="-fno-access-control" [13]="-fno-elide-constructors" [14]="-fno-enforce-eh-specs" [15]="-fno-extern-tls-init" [16]="-fno-for-scope" [17]="-fno-gnu-keywords" [18]="-fno-implement-inlines" [19]="-fno-implicit-*" [20]="-fno-nonansi-builtins" [21]="-fno-operator-names" [22]="-fno-optional-diags" [23]="-fno-pretty-templates" [24]="-fno-rtti" [25]="-fno-threadsafe-statics" [26]="-fno-use-cxa-get-exception-ptr" [27]="-fno-weak" [28]="-fnothrow-opt" [29]="-fpermissive" [30]="-frepo" [31]="-fsized-deallocation" [32]="-fstrict-enums" [33]="-fstrong-eval-order" [34]="-ftemplate-*" [35]="-fuse-cxa-atexit" [36]="-fvisibility-*" [37]="-nostdinc++" [38]="-std=c++*" [39]="-std=gnu++*" [40]="-Wabi*" [41]="-Wctor-dtor-privacy" [42]="-Wdelete-non-virtual-dtor" [43]="-Weffc++" [44]="-Wliteral-suffix" [45]="-Wlto-type-mismatch" [46]="-Wmultiple-inheritance" [47]="-Wnamespaces" [48]="-Wno-narrowing" [49]="-Wno-non-template-friend" [50]="-Wno-pmf-conversions" [51]="-Wno-terminate" [52]="-Wnoexcept" [53]="-Wnon-virtual-dtor" [54]="-Wold-style-cast" [55]="-Woverloaded-virtual" [56]="-Wregister" [57]="-Wreorder" [58]="-Wsign-promo" [59]="-Wstrict-null-sentinel" [60]="-Wtemplates" [61]="-Wvirtual-inheritance")
declare -a FLAG_FILTER_F77FLAGS=()
declare -a FLAG_FILTER_FCFLAGS=()
declare -a FLAG_FILTER_FFLAGS=()
declare -a FLAG_FILTER_FORTRAN=([0]="-ansi" [1]="-fallow-parameterless-variadic-functions" [2]="-fcilkplus" [3]="-fcond-mismatch" [4]="-fdirectives-only" [5]="-ffreestanding" [6]="-fgimple" [7]="-fgnu-tm" [8]="-fgnu89-inline" [9]="-fhosted" [10]="-flax-vector-conversions" [11]="-fms-extensions" [12]="-fno-asm" [13]="-fno-builtin*" [14]="-fno-signed-bitfields" [15]="-fno-unsigned-bitfields" [16]="-fpermitted-flt-eval-methods*" [17]="-fplan9-extensions" [18]="-fsigned-*" [19]="-fsso-struct*" [20]="-funsigned-*" [21]="-Wformat*" [22]="-Wchkp")
declare -a FLAG_FILTER_GNU=([0]="-emit-llvm" [1]="-flto=[a-z]*" [2]="-flto-jobs=*" [3]="-fopenmp=*" [4]="-frewrite-includes" [5]="-fsanitize=cfi" [6]="-fsanitize=safe-stack" [7]="-mllvm" [8]="-mretpoline*" [9]="-polly*" [10]="-Wl,-z,retpolineplt")
declare -a FLAG_FILTER_NONGNU=([0]="-fcf-protection*" [1]="-fdevirtualize-at-ltrans" [2]="-fdevirtualize-speculatively" [3]="-fdirectives-only" [4]="-fgcse*" [5]="-fgraphite*" [6]="-finline-functions" [7]="-fipa-pta" [8]="-fira-loop-pressure" [9]="-fisolate-erroneous-paths-attribute" [10]="-fivopts" [11]="-floop*" [12]="-flto=[0-9]*" [13]="-flto-partition=*" [14]="-flto-compression-level=*" [15]="-fmodulo*" [16]="-fno-enforce-eh-specs" [17]="-fno-ident" [18]="-fno-plt" [19]="-fno-semantic-interposition" [20]="-fnothrow-opt" [21]="-fpredictive-commoning" [22]="-frename-registers" [23]="-freorder-functions" [24]="-frerun-cse-after-loop" [25]="-fsched*" [26]="-fsection-anchors" [27]="-fstack-clash-protection" [28]="-ftree*" [29]="-funsafe-loop*" [30]="-fuse-linker-plugin" [31]="-fvect-cost-model" [32]="-fweb" [33]="-fwhole-program" [34]="-mfunction-return*" [35]="-mindirect-branch*" [36]="-mvectorize*" [37]="-Wl,-z,retpolineplt")
declare -x FLTO="-flto=8"
declare -x GCC_SPECS=""
declare -x GDK_BACKEND="x11"
declare -x GDMSESSION="cinnamon"
declare -x GDM_LANG="bg_BG.utf8"
declare -x GJS_DEBUG_OUTPUT="stderr"
declare -x GJS_DEBUG_TOPICS="JS ERROR;JS LOG"
declare -x GNOME="gtk gnome -cups -bluetooth -cdr -tracker -games -qt5 -kde networkmanager"
declare -x GNOME_DESKTOP_SESSION_ID="this-is-deprecated"
declare -x GPSD_PROTOCOLS=""
declare -x GRAPHITE="-fgraphite-identity -floop-nest-optimize"
declare -x GRUB_PLATFORMS=""
declare -x GSETTINGS_BACKEND="dconf"
declare -x GTK_MODULES="canberra-gtk-module"
declare -x GTK_OVERLAY_SCROLLING="1"
declare -x GUI="X wayland"
declare HDEPEND=""
declare -x HISTSIZE="5000"
declare HOMEPAGE="https://gitlab.freedesktop.org/mesa/glu"
declare -x INFINALITY_FT_AUTOHINT_HORIZONTAL_STEM_DARKEN_STRENGTH="10"
declare -x INFINALITY_FT_AUTOHINT_INCREASE_GLYPH_HEIGHTS="true"
declare -x INFINALITY_FT_AUTOHINT_SNAP_STEM_HEIGHT="100"
declare -x INFINALITY_FT_AUTOHINT_VERTICAL_STEM_DARKEN_STRENGTH="25"
declare -x INFINALITY_FT_BOLD_EMBOLDEN_X_VALUE="0"
declare -x INFINALITY_FT_BOLD_EMBOLDEN_Y_VALUE="0"
declare -x INFINALITY_FT_BRIGHTNESS="0"
declare -x INFINALITY_FT_CHROMEOS_STYLE_SHARPENING_STRENGTH="0"
declare -x INFINALITY_FT_CONTRAST="0"
declare -x INFINALITY_FT_FILTER_PARAMS="11 22 38 22 11"
declare -x INFINALITY_FT_FRINGE_FILTER_STRENGTH="0"
declare -x INFINALITY_FT_GAMMA_CORRECTION="0 100"
declare -x INFINALITY_FT_GLOBAL_EMBOLDEN_X_VALUE="0"
declare -x INFINALITY_FT_GLOBAL_EMBOLDEN_Y_VALUE="0"
declare -x INFINALITY_FT_GRAYSCALE_FILTER_STRENGTH="0"
declare -x INFINALITY_FT_STEM_ALIGNMENT_STRENGTH="25"
declare -x INFINALITY_FT_STEM_FITTING_STRENGTH="25"
declare -x INFINALITY_FT_STEM_SNAPPING_SLIDING_SCALE="40"
declare -x INFINALITY_FT_USE_KNOWN_SETTINGS_ON_SELECTED_FONTS="true"
declare -x INFINALITY_FT_USE_VARIOUS_TWEAKS="true"
declare -x INFINALITY_FT_WINDOWS_STYLE_SHARPENING_STRENGTH="5"
declare -x INHERITED=" toolchain-funcs multilib libtool autotools epatch desktop estack ltprune preserve-libs vcs-clean eutils autotools-utils multibuild multilib-build multilib-minimal autotools-multilib"
declare -x INPUT_DEVICES=""
declare -x INSDESTTREE=""
declare -x INSOPTIONS="-m0644"
declare -x IPAPTA="-fipa-pta"
declare IUSE="static-libs abi_x86_32 abi_x86_64 abi_x86_x32 abi_mips_n32 abi_mips_n64 abi_mips_o32 abi_riscv_lp64d abi_riscv_lp64 abi_s390_32 abi_s390_64"
declare -x IUSE_EFFECTIVE="abi_mips_n32 abi_mips_n64 abi_mips_o32 abi_riscv_lp64 abi_riscv_lp64d abi_s390_32 abi_s390_64 abi_x86_32 abi_x86_64 abi_x86_x32 alpha amd64 amd64-fbsd amd64-linux arm arm64 elibc_AIX elibc_Cygwin elibc_Darwin elibc_DragonFly elibc_FreeBSD elibc_HPUX elibc_Interix elibc_NetBSD elibc_OpenBSD elibc_SunOS elibc_Winnt elibc_bionic elibc_glibc elibc_mingw elibc_mintlib elibc_musl elibc_uclibc hppa ia64 kernel_AIX kernel_Darwin kernel_FreeBSD kernel_HPUX kernel_NetBSD kernel_OpenBSD kernel_SunOS kernel_Winnt kernel_freemint kernel_linux m68k m68k-mint mips ppc ppc-aix ppc-macos ppc64 ppc64-linux prefix prefix-guest prefix-stack riscv s390 sh sparc sparc-solaris sparc64-solaris static-libs userland_BSD userland_GNU x64-cygwin x64-macos x64-solaris x86 x86-cygwin x86-fbsd x86-linux x86-macos x86-solaris x86-winnt"
declare -x IUSE_IMPLICIT="abi_x86_64 prefix prefix-guest prefix-stack"
declare -x JAVAC="/etc/java-config-2/current-system-vm/bin/javac"
declare -x JAVA_HOME="/etc/java-config-2/current-system-vm"
declare -x JDK_HOME="/etc/java-config-2/current-system-vm"
declare -- KEEPPGO=":"
declare -x KERNEL="linux"
declare -x KERNEL_ABI="amd64"
declare -x KEYWORDS="alpha amd64 arm arm64 hppa ia64 ~mips ppc ppc64 s390 ~sh sparc x86 ~amd64-fbsd ~x86-fbsd ~amd64-linux ~x86-linux ~sparc-solaris ~x64-solaris ~x86-solaris"
declare -x L10N=""
declare -x LADSPA_PATH="/usr/lib64/ladspa"
declare -x LANG="bg_BG.utf8"
declare -x LCD_DEVICES=""
declare -x LC_COLLATE="C"
declare -x LC_CTYPE="bg_BG.utf8"
declare -x LC_MESSAGES="C"
declare -x LDFLAGS="-Wl,-O1 -Wl,--as-needed -Wl,--hash-style=gnu -march=bdver2 -O3 -fgraphite-identity -floop-nest-optimize -fdevirtualize-at-ltrans -fipa-pta -fno-semantic-interposition -flto=8 -fuse-linker-plugin -fuse-ld=gold -pipe"
declare -x LDFLAGS_amd64="-m elf_x86_64"
declare -x LDFLAGS_default
declare -x LDFLAGS_x32="-m elf32_x86_64"
declare -x LDFLAGS_x86="-m elf_i386"
declare -x LIBDIR_amd64="lib64"
declare -x LIBDIR_default="lib"
declare -x LIBDIR_x32="libx32"
declare -x LIBDIR_x86="lib"
declare -x LIBOPTIONS="-m0644"
declare -x LIBREOFFICE_EXTENSIONS=""
declare -x LICENSE="SGI-B-2.0"
declare -x LINGUAS="bg_BG en_US"
declare -x LIRC_DEVICES=""
declare -x LLVM_TARGETS=""
declare -x LSCOLORS="Gxfxcxdxbxegedabagacad"
declare -x LV2_PATH="/usr/lib64/lv2"
declare -x MAIL="/var/mail/rosen"
declare -x MAKEOPTS="-j8 -l9"
declare -x MANPAGER="manpager"
declare -x MONKEYD_PLUGINS=""
declare -x MOZ_GMP_PATH="/usr/lib64/nsbrowser/plugins/gmp-gmpopenh264/system-installed"
declare -x MULTILIB_ABIS="amd64 x86"
declare -x MULTILIB_STRICT_DENY="64-bit.*shared object"
declare -x MULTILIB_STRICT_DIRS="/lib32 /lib /usr/lib32 /usr/lib /usr/kde/*/lib32 /usr/kde/*/lib /usr/qt/*/lib32 /usr/qt/*/lib /usr/X11R6/lib32 /usr/X11R6/lib"
declare -x MULTILIB_STRICT_EXEMPT="(perl5|gcc|gcc-lib|binutils|eclipse-3|debug|portage|udev|systemd|clang|python-exec|llvm)"
declare -- MULTILIB_USEDEP="abi_x86_32(-)?,abi_x86_64(-)?,abi_x86_x32(-)?,abi_mips_n32(-)?,abi_mips_n64(-)?,abi_mips_o32(-)?,abi_riscv_lp64d(-)?,abi_riscv_lp64(-)?,abi_s390_32(-)?,abi_s390_64(-)?"
declare -x NETBEANS_MODULES=""
declare -x NGINX_MODULES_HTTP=""
declare -x NGINX_MODULES_MAIL=""
declare -x NGINX_MODULES_STREAM=""
declare -x NOCOMMON="-fno-common"
declare -x NOPLT="-fno-plt"
declare -x NTHREADS="8"
declare -x OFED_DRIVERS=""
declare -x OFFICE_IMPLEMENTATION=""
declare -x OPENCL_PROFILE="ocl-icd"
declare -x OPENGL_PROFILE="xorg-x11"
declare -x OPENMPI_FABRICS=""
declare -x OPENMPI_OFED_FEATURES=""
declare -x OPENMPI_RM=""
declare -x PACKAGE_MANAGER="portage"
declare -x PATH="/usr/lib/portage/python3.6/ebuild-helpers/xattr:/usr/lib/portage/python3.6/ebuild-helpers:/usr/lib/llvm/8/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/bin"
declare PDEPEND=""
declare -- PGO_DIR="/var/cache/pgo/media-libs:glu-9.0.0"
declare -- PGO_PARENT="/var/cache/pgo"
declare -x PHP_TARGETS=""
declare -x PKG_CONFIG_PATH="/usr/lib64/pkgconfig"
declare -x PLUGINS="nsplugin vdpau vaapi ladspa bs2b"
declare -x PORTAGE_COMPRESSION_COMMAND="bzip2"
declare -a PORTAGE_DOCOMPRESS=([0]="/usr/share/doc" [1]="/usr/share/info" [2]="/usr/share/man")
declare -x PORTAGE_DOCOMPRESS_SIZE_LIMIT="128"
declare -a PORTAGE_DOCOMPRESS_SKIP=([0]="/usr/share/doc/glu-9.0.0-r1/html")
declare -a PORTAGE_DOSTRIP=([0]="/")
declare -a PORTAGE_DOSTRIP_SKIP=()
declare -x PORTAGE_NICENESS="15"
declare -x PORT_LOGDIR="/portage/log"
declare -x POSTGRES_TARGETS=""
declare -x PROFILE_ONLY_VARIABLES="ARCH ELIBC IUSE_IMPLICIT KERNEL USERLAND USE_EXPAND_IMPLICIT USE_EXPAND_UNPREFIXED USE_EXPAND_VALUES_ARCH USE_EXPAND_VALUES_ELIBC USE_EXPAND_VALUES_KERNEL USE_EXPAND_VALUES_USERLAND"
declare -x PROPERTIES=""
declare -x PROTOCOLS="mtp"
declare -x PYTHONDONTWRITEBYTECODE="1"
declare -x PYTHON_SINGLE_TARGET=""
declare -x PYTHON_TARGETS=""
declare -x QEMU_SOFTMMU_TARGETS=""
declare -x QEMU_USER_TARGETS=""
declare RDEPEND=">=virtual/opengl-7.0-r1[abi_x86_32(-)?,abi_x86_64(-)?,abi_x86_x32(-)?,abi_mips_n32(-)?,abi_mips_n64(-)?,abi_mips_o32(-)?,abi_riscv_lp64d(-)?,abi_riscv_lp64(-)?,abi_s390_32(-)?,abi_s390_64(-)?]
	!<media-libs/mesa-9 "
declare REPOSITORY
declare REQUIRED_USE=""
declare -x RESTRICT=""
declare -x RESUMECOMMAND_SSH="bash -c \"x=\\\${2#ssh://} ; host=\\\${x%%/*} ; port=\\\${host##*:} ; host=\\\${host%:*} ; [[ \\\${host} = \\\${port} ]] && port= ; exec rsync --rsh=\\\"ssh \\\${port:+-p\\\${port}} \\\${3}\\\" -avP \\\"\\\${host}:/\\\${x#*/}\\\" \\\"\\\$1\\\"\" rsync \"\${DISTDIR}/\${FILE}\" \"\${URI}\" \"\${PORTAGE_SSH_OPTS}\""
declare -x ROS_MESSAGES=""
declare -x RUBY_TARGETS=""
declare -x S="/portage/tmp/portage/media-libs/glu-9.0.0-r1/work/glu-9.0.0"
declare -x SAFER_FAST_MATH="-fno-signed-zeros -fno-trapping-math -fassociative-math -freciprocal-math -fno-math-errno -ffinite-math-only -fno-rounding-math -fno-signaling-nans -fcx-limited-range -fexcess-precision=fast"
declare -x SAFER_UNSAFE_MATH_OPTS="-fno-signed-zeros -fno-trapping-math -fassociative-math -freciprocal-math"
declare -x SAFEST_FAST_MATH="-fno-math-errno -fno-trapping-math"
declare -x SANDBOX_DEBUG="0"
declare -x SANDBOX_DENY=""
declare -x SANDBOX_PREDICT="/portage/tmp/portage/media-libs/glu-9.0.0-r1/homedir:/dev/crypto:/var/cache/man:/proc/self/coredump_filter:/var/cache/fontconfig"
declare -x SANDBOX_READ="/:/portage/tmp/portage"
declare -x SANDBOX_VERBOSE="1"
declare -x SANDBOX_WRITE=":/dev/console:/dev/fd:/dev/full:/dev/null:/dev/ptmx:/dev/pts/:/dev/pty:/dev/shm:/dev/tts:/dev/tty:/dev/vc/:/dev/zero:/portage/tmp/portage:/portage/tmp/portage/media-libs/glu-9.0.0-r1/homedir/.bash_history:/proc/self/fd:/tmp/:/usr/lib/cf:/usr/lib/conftest:/usr/lib32/cf:/usr/lib32/conftest:/usr/lib64/cf:/usr/lib64/conftest:/usr/tmp/cf:/usr/tmp/conftest:/var/tmp/"
declare -x SANE_BACKENDS=""
declare -x SAVEHIST="5000"
declare -x SECURITY="apparmor"
declare -x SEMINTERPOS="-fno-semantic-interposition"
declare -x SESSION_MANAGER="local/GA990-FXA-UD3-FX8320:@/tmp/.ICE-unix/995,unix/GA990-FXA-UD3-FX8320:/tmp/.ICE-unix/995"
declare -x SHELL="/bin/zsh"
declare -x SLOT="0"
declare SRC_URI="https://mesa.freedesktop.org/archive/glu/glu-9.0.0.tar.bz2"
declare -x STEAM_NATIVE="-steamruntime"
declare -x SYMLINK_LIB="no"
declare -x SYS="-bindist dbus branding zsh-completion nls icu fontconfig truetype unicode infinality command-not-found fat"
declare -x TWISTED_DISABLE_WRITING_OF_PLUGIN_CACHE="1"
declare -x USE="abi_x86_32 abi_x86_64 amd64 elibc_glibc kernel_linux userland_GNU"
declare -x USERLAND="GNU"
declare -x USE_EXPAND_IMPLICIT="ARCH ELIBC KERNEL USERLAND"
declare -x USE_EXPAND_UNPREFIXED="ARCH"
declare -x USE_EXPAND_VALUES_ARCH="alpha amd64 amd64-fbsd amd64-linux arm arm64 hppa ia64 m68k m68k-mint mips ppc ppc64 ppc64-linux ppc-aix ppc-macos riscv s390 sh sparc sparc64-solaris sparc-solaris x64-cygwin x64-macos x64-solaris x86 x86-cygwin x86-fbsd x86-linux x86-macos x86-solaris x86-winnt"
declare -x USE_EXPAND_VALUES_ELIBC="AIX bionic Cygwin Darwin DragonFly FreeBSD glibc HPUX Interix mingw mintlib musl NetBSD OpenBSD SunOS uclibc Winnt"
declare -x USE_EXPAND_VALUES_KERNEL="AIX Darwin FreeBSD freemint HPUX linux NetBSD OpenBSD SunOS Winnt"
declare -x USE_EXPAND_VALUES_USERLAND="BSD GNU"
declare -x UWSGI_PLUGINS=""
declare -x VBOX_APP_HOME="/usr/lib64/virtualbox"
declare -x VIDEO_CARDS=""
declare -x VOICEMAIL_STORAGE=""
declare -x VTE_VERSION="5404"
declare -x WANT_AUTOCONF="latest"
declare -x WANT_AUTOMAKE="latest"
declare -x WANT_LIBTOOL="latest"
declare -x XDG_CONFIG_DIRS="/etc/xdg"
declare -x XDG_CURRENT_DESKTOP="X-Cinnamon"
declare -x XDG_DATA_DIRS="/home/rosen/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share:/var/lib/snapd/desktop"
declare -x XDG_GREETER_DATA_DIR="/var/lib/lightdm-data/rosen"
declare -x XDG_RUNTIME_DIR="/run/user/1000"
declare -x XDG_SEAT="seat0"
declare -x XDG_SEAT_PATH="/org/freedesktop/DisplayManager/Seat0"
declare -x XDG_SESSION_CLASS="user"
declare -x XDG_SESSION_DESKTOP="cinnamon"
declare -x XDG_SESSION_ID="2"
declare -x XDG_SESSION_PATH="/org/freedesktop/DisplayManager/Session0"
declare -x XDG_SESSION_TYPE="x11"
declare -x XDG_VTNR="7"
declare -x XFCE_PLUGINS=""
declare -x XFS="xfs"
declare -x XTABLES_ADDONS=""
declare -x YSU_VERSION="0.5.0"
declare -x ZSH="/usr/share/zsh/site-contrib/oh-my-zsh"
declare -x ZSHPLUGINS="/home/zsh-plugins"
declare -- _AUTOTOOLS_ECLASS="1"
declare -- _DESKTOP_ECLASS="1"
declare -- _EPATCH_ECLASS="1"
declare -- _ESTACK_ECLASS="1"
declare -- _EUTILS_ECLASS="1"
declare -x _E_DOCDESTTREE_=""
declare -x _E_EXEDESTTREE_=""
declare -a _LATEST_AUTOMAKE=([0]="1.16.1:1.16" [1]="1.15.1:1.15")
declare -- _LIBTOOL_ECLASS="1"
declare -- _LTPRUNE_ECLASS="1"
declare -- _MULTIBUILD="1"
declare -- _MULTILIB_BUILD="1"
declare -- _MULTILIB_ECLASS="1"
declare -a _MULTILIB_FLAGS=([0]="abi_x86_32:x86,x86_fbsd,x86_freebsd,x86_linux,x86_macos,x86_solaris" [1]="abi_x86_64:amd64,amd64_fbsd,x64_freebsd,amd64_linux,x64_macos,x64_solaris" [2]="abi_x86_x32:x32" [3]="abi_mips_n32:n32" [4]="abi_mips_n64:n64" [5]="abi_mips_o32:o32" [6]="abi_riscv_lp64d:lp64d" [7]="abi_riscv_lp64:lp64" [8]="abi_s390_32:s390" [9]="abi_s390_64:s390x")
declare -- _PRESERVE_LIBS_ECLASS="1"
declare -- _TOOLCHAIN_FUNCS_ECLASS="1"
declare -- __AUTOTOOLS_AUTO_DEPEND="no"
declare -- _libtool_atom=">=sys-devel/libtool-2.4"
declare -- bashrcd_phases_0_compile="FlagCompile"
declare -- bashrcd_phases_0_preinst="FlagPreinst"
declare -- bashrcd_phases_0_prepare="LTOPatch"
declare -- bashrcd_phases_0_setup="QlopSetup"
declare -- bashrcd_phases_1_preinst="LocalePurge"
declare -- bashrcd_phases_1_setup="FlagSetup"
declare -- bashrcd_phases_2_preinst="Remove_la"
declare -- bashrcd_phases_c_compile="0"
declare -- bashrcd_phases_c_preinst="2"
declare -- bashrcd_phases_c_prepare="0"
declare -- bashrcd_phases_c_setup="1"
declare -- phase_func
BashrcdEcho () 
{ 
    local i m=einfo;
    BashrcdTrue $BASHRCDLOG && m=elog;
    for i in "$@";
    do
        $m "$i";
    done
}
BashrcdLog () 
{ 
    local i m=elog;
    BashrcdTrue $BASHRCDNOLOG && m=einfo;
    for i in "$@";
    do
        $m "$i";
    done
}
BashrcdMain () 
{ 
    local bashrcd_ebuild_phase bashrcd_phase bashrcd_num bashrcd_max;
    bashrcd_ebuild_phase=$EBUILD_PHASE;
    [ -n "${bashrcd_ebuild_phase:++}" ] || [ $# -eq 0 ] || bashrcd_ebuild_phase=$1;
    : ${ED:=${D%/}${EPREFIX%/}/};
    BashrcdTrue $BASHRCD_DEBUG && BashrcdEcho "$0: $* ($# args)" "EBUILD_PHASE=$EBUILD_PHASE" "PORTDIR=$PORTDIR" "CATEGORY=$CATEGORY" "P=$P" "USER=$USER" "UID=$UID" "HOME=$HOME" "PATH=$PATH" "ROOT=$ROOT" "PORTAGE_CONFIGROOT=$PORTAGE_CONFIGROOT" "LD_PRELOAD=$LD_PRELOAD" "EPREFIX=$EPREFIX" "D=$D" "ED=$ED";
    for bashrcd_phase in all "$bashrcd_ebuild_phase";
    do
        eval bashrcd_max=\${bashrcd_phases_c_$bashrcd_phase};
        [ -z "${bashrcd_max:++}" ] && continue;
        bashrcd_num=0;
        while { 
            eval eval \"\\\${bashrcd_phases_${bashrcd_num}_$bashrcd_phase}\";
            [ $bashrcd_num -ne $bashrcd_max ]
        }; do
            bashrcd_num=$(( $bashrcd_num + 1 ));
        done;
    done
}
BashrcdTrue () 
{ 
    case ${1:-n} in 
        [nNfF]* | [oO][fF]* | 0 | -)
            return 1
        ;;
    esac;
    :
}
FlagAdd () 
{ 
    FlagNodupAdd '' "$@"
}
FlagAddAllFlags () 
{ 
    FlagAddCFlags "$@"
}
FlagAddCFlags () 
{ 
    FlagAdd CFLAGS "$@";
    FlagAdd CXXFLAGS "$@"
}
FlagAthlon () 
{ 
    FlagSubCFlags '-march=*';
    FlagAddCFlags '-march=athlon-4';
    command -v x86_64-pc-linux-gnu-gcc32 > /dev/null 2>&1 && export CC=x86_64-pc-linux-gnu-gcc32;
    command -v x86_64-pc-linux-gnu-g++32 > /dev/null 2>&1 && export CXX=x86_64-pc-linux-gnu-g++32
}
FlagCompile () 
{ 
    :
}
FlagEval () 
{ 
    case $- in 
        *f*)
            eval "$*"
        ;;
        *)
            set -f;
            eval "$*";
            set +f
        ;;
    esac
}
FlagExecute () 
{ 
    local ex exy excurr;
    for excurr in "$@";
    do
        case $excurr in 
            '#'*)
                return
            ;;
            '!'*)
                [ "$HOSTTYPE" = 'i686' ] || continue;
                ex=${excurr#?}
            ;;
            '~'*)
                [ "$HOSTTYPE" = 'x86_64' ] || continue;
                ex=${excurr#?}
            ;;
            *)
                ex=$excurr
            ;;
        esac;
        case $ex in 
            /*/*)
                ex=${ex%/};
                ex=${ex#/};
                FlagEval FlagReplaceAllFlags "${ex%%/*}" "${ex#*/}"
            ;;
            '-'*)
                FlagAddAllFlags "$ex"
            ;;
            '+flto*')
                FlagSubAllFlags '-flto*' '-fuse-linker-plugin' '-emit-llvm'
            ;;
            '+'*)
                FlagSubAllFlags "-${ex#+}"
            ;;
            'C*FLAGS-='*)
                FlagEval FlagSubCFlags ${ex#*-=}
            ;;
            'C*FLAGS+='*)
                FlagEval FlagAddCFlags ${ex#*+=}
            ;;
            'C*FLAGS='*)
                FlagEval FlagSetAllCFlags "${ex#*=}"
            ;;
            'C*FLAGS/=/'*/*)
                ex=${ex%/};
                ex=${ex#*/=/};
                FlagEval FlagReplaceCFlags "${ex%%/*}" "${ex#*/}"
            ;;
            '*FLAGS-='*)
                FlagEval FlagSubAllFlags ${ex#*-=}
            ;;
            '*FLAGS+='*)
                FlagEval FlagAddAllFlags ${ex#*+=}
            ;;
            '*FLAGS='*)
                FlagEval FlagSetAllFlags "${ex#*=}"
            ;;
            '*FLAGS/=/'*/*)
                ex=${ex%/};
                ex=${ex#*/=/};
                FlagEval FlagReplaceAllFlags "${ex%%/*}" "${ex#*/}"
            ;;
            'ATHLON32')
                FlagAthlon
            ;;
            'NOC*OPT='* | 'NOC*='*)
                FlagEval FlagSet NOCOPT "${ex#*=}";
                NOCXXOPT=$NOCOPT;
                NOCPPOPT=$NOCOPT
            ;;
            'NO*OPT='*)
                FlagEval FlagSet NOCOPT "${ex#*=}";
                NOCXXOPT=$NOCOPT;
                NOCPPOPT=$NOCOPT;
                NOLDOPT=$NOCOPT
            ;;
            'NOLD*='*)
                FlagEval FlagSet NOLDOPT "${ex#*=}";
                NOLDADD=$NOLDOPT
            ;;
            'NO*'*)
                FlagEval FlagSet NOCOPT "${ex#*=}";
                NOCXXOPT=$NOCOPT;
                NOCPPOPT=$NOCOPT;
                NOLDOPT=$NOCOPT;
                NOLDADD=$NOCOPT;
                NOFFLAGS=$NOCOPT;
                NOFCFLAGS=$NOCOPT;
                NOF77FLAGS=$NOCOPT
            ;;
            'SAFE')
                NOCOPT=1;
                NOCXXOPT=1;
                NOCPPOPT=1;
                NOLDOPT=1;
                MESONDEDUP=1;
                LDFLAGS=;
                CONFIG_SITE=;
                NOLAFILEREMOVE=1;
                unset CMAKE_MAKEFILE_GENERATOR
            ;;
            *' '*'='*)
                FlagEval "$ex"
            ;;
            *'/=/'*'/'*)
                ex=${ex%/};
                exy=${ex#*/=/};
                FlagEval FlagReplace "${ex%%/=/*}" "${exy%%/*}" "${exy#*/}"
            ;;
            *'-='*)
                FlagEval FlagSub "${ex%%-=*}" ${ex#*-=}
            ;;
            *'+='*)
                FlagEval FlagAdd "${ex%%+=*}" ${ex#*+=}
            ;;
            *'='*)
                FlagEval FlagSet "${ex%%=*}" "${ex#*=}"
            ;;
            *)
                FlagEval "$ex"
            ;;
        esac;
    done
}
FlagInfoExport () 
{ 
    local out;
    for out in FEATURES CFLAGS CXXFLAGS CPPFLAGS FFLAGS FCFLAGS F77FLAGS LDFLAGS MAKEOPTS EXTRA_ECONF EXTRA_EMAKE USE_NONGNU;
    do
        eval "if [ -n \"\${$out:++}\" ]
		then	export $out
			BashrcdEcho \"$out='\$$out'\"
		else	unset $out
		fi";
    done;
    if BashrcdTrue $PGO; then
        BashrcdEcho "Create PGO into $PGO_DIR";
    else
        if $use_pgo; then
            BashrcdEcho "Using PGO from $PGO_DIR";
        fi;
    fi;
    out=`gcc --version | head -n 1` || out=;
    BashrcdEcho "${out:-cannot determine gcc version}";
    BashrcdEcho "`uname -a`"
}
FlagMask () 
{ 
    masked-packages -qm "$1" -- "$CATEGORY/$PF:${SLOT:-0}${PORTAGE_REPO_NAME:+::}${PORTAGE_REPO_NAME-}"
}
FlagMesonDedup () 
{ 
    local newld=;
    FlagNodupAdd "$CFLAGS $CXXFLAGS $CPPFLAGS $FFLAGS $FCFLAGS $F77FLAGS" newld $LDFLAGS;
    LDFLAGS=$newld
}
FlagNodupAdd () 
{ 
    local addres addf addvar dups;
    dups=$1;
    shift;
    addvar=$1;
    shift;
    eval addres=\$$addvar;
    for addf in "$@";
    do
        case " $addres $dups " in 
            *[[:space:]]"$addf"[[:space:]]*)
                continue
            ;;
        esac;
        addres=$addres${addres:+\ }$addf;
    done;
    eval $addvar=\$addres
}
FlagParseLine () 
{ 
    local scanp scanl scansaveifs;
    scanl=$2;
    while :; do
        case $scanl in 
            [[:space:]]*)
                scanl=${scanl#?};
                continue
            ;;
            '#'*)
                return
            ;;
            *[[:space:]]*)
                break
            ;;
        esac;
        return;
    done;
    scanp=${scanl%%[[:space:]]*};
    scanl=${scanl#*[[:space:]]};
    [ -n "${scanl:++}" ] || return 0;
    FlagMask "$scanp" || return 0;
    scansaveifs=$IFS;
    IFS=$1;
    BashrcdEcho "$scanfile -> $scanp: $scanl";
    FlagEval FlagExecute $scanl;
    IFS=$scansaveifs
}
FlagPreinst () 
{ 
    :
}
FlagReplace () 
{ 
    local repres repf repcurr repvar reppat repfound;
    repvar=$1;
    shift;
    eval repf=\$$repvar;
    reppat=$1;
    shift;
    if [ -z "${repf:++}" ]; then
        eval $repvar=\$*;
        return;
    fi;
    repres=;
    repfound=:;
    for repcurr in $repf;
    do
        case $repcurr in 
            $reppat)
                $repfound && FlagAdd repres "$@";
                repfound=false;
                continue
            ;;
        esac;
        repres=$repres${repres:+\ }$repcurr;
    done;
    $repfound && FlagAdd repres "$@";
    eval $repvar=\$repres
}
FlagReplaceAllFlags () 
{ 
    FlagReplaceCFlags "$@";
    FlagSub LDFLAGS "$1";
    FlagSub OPTLDFLAGS "$1";
    FlagSub FFLAGS "$1";
    FlagSub FCLAGS "$1";
    FlagSub F77FLAGS "$1"
}
FlagReplaceCFlags () 
{ 
    FlagReplace CFLAGS "$@";
    FlagReplace CXXFLAGS "$@";
    FlagReplace CPPFLAGS "$@";
    FlagSub OPTCFLAGS "$1";
    FlagSub OPTCXXFLAGS "$1";
    FlagSub OPTCPPFLAGS "$1"
}
FlagScanDir () 
{ 
    local scantmp scanifs scanfile;
    scanifs=$IFS;
    if test -d "$1"; then
        IFS='
';
        for scantmp in `find -L "$1" 		'(' '(' -name '.*' -o -name '*~' ')' -prune ')' -o 			-type f -print`;
        do
            IFS=$scanifs;
            FlagScanFiles "$scantmp";
        done;
    else
        FlagScanFiles "$1";
    fi;
    scanfile='FLAG_ADDLINES';
    IFS='
';
    for scantmp in $FLAG_ADDLINES;
    do
        FlagParseLine "$scanifs" "$scantmp";
    done;
    IFS=$scanifs
}
FlagScanFiles () 
{ 
    local scanfile scanl oldifs scanifs;
    scanifs=$IFS;
    IFS=;
    for scanfile in "$@";
    do
        [ -z "${scanfile:++}" ] && continue;
        test -r "$scanfile" || continue;
        while read -r scanl; do
            FlagParseLine "$scanifs" "$scanl";
        done < "$scanfile";
    done;
    IFS=$scanifs
}
FlagSet () 
{ 
    local setvar;
    setvar=$1;
    shift;
    eval $setvar=\$*
}
FlagSetAllCFlags () 
{ 
    FlagSet CFLAGS "$@";
    CXXFLAGS=$CFLAGS;
    CPPFLAGS=;
    OPTCFLAGS=;
    OPTCXXFLAGS=;
    OPTCPPFLAGS=
}
FlagSetAllFlags () 
{ 
    FlagSetAllCFlags "$@";
    LDFLAGS=;
    OPTLDFLAGS=
}
FlagSetFlags () 
{ 
    local ld i;
    ld=;
    : ${PGO_PARENT:=/var/cache/pgo};
    : ${PGO_DIR:=$PGO_PARENT/$CATEGORY:$P};
    FlagScanDir "${PORTAGE_CONFIGROOT%/}/etc/portage/package.cflags";
    [ -z "${USE_NONGNU++}" ] && FlagSetUseNonGNU && USE_NONGNU=1;
    if BashrcdTrue "${USE_NONGNU-}"; then
        FlagSetNonGNU;
    else
        FlagSetGNU;
    fi;
    if [ -n "$FLAG_ADD" ]; then
        BashrcdEcho "FLAG_ADD: $FLAG_ADD";
        FlagEval FlagExecute "$FLAG_ADD";
    fi;
    PGO_DIR=${PGO_DIR%/};
    case ${PGO_DIR:-/} in 
        /)
            error 'PGO_DIR must not be empty';
            false
        ;;
        /*)
            :
        ;;
        *)
            error 'PGO_DIR must be an absolute path';
            false
        ;;
    esac || { 
        die 'Bad PGO_DIR';
        exit 2
    };
    use_pgo=false;
    if test -r "$PGO_DIR"; then
        unset PGO;
        BashrcdTrue $NOPGO || use_pgo=:;
    fi;
    if BashrcdTrue $PGO; then
        FlagAddCFlags "-fprofile-generate=$PGO_DIR" -fvpt -fprofile-arcs;
        FlagAdd LDFLAGS -fprofile-arcs;
        addpredict "$PGO_PARENT";
    else
        if $use_pgo; then
            FlagAddCFlags "-fprofile-use=$PGO_DIR" -fvpt -fbranch-probabilities -fprofile-correction;
        else
            : ${KEEPPGO:=:};
        fi;
    fi;
    BashrcdTrue $NOLDOPT || FlagAdd LDFLAGS $OPTLDFLAGS;
    BashrcdTrue $NOCADD || BashrcdTrue $MESONDEDUP || case " $LDFLAGS $CFLAGS $CXXFLAGS" in 
        *[[:space:]]'-flto'*)
            ld="$CFLAGS $CXXFLAGS"
        ;;
    esac;
    BashrcdTrue $NOLDADD || BashrcdTrue $MESONDEDUP || FlagAddCFlags $LDFLAGS;
    FlagAdd LDFLAGS $ld;
    BashrcdTrue $NOCOPT || FlagAdd CFLAGS $OPTCFLAGS;
    BashrcdTrue $NOCXXOPT || FlagAdd CXXFLAGS $OPTCXXFLAGS;
    BashrcdTrue $NOCPPOPT || FlagAdd CPPFLAGS $OPTCPPFLAGS;
    BashrcdTrue $NOFFLAGS || FFLAGS=$CFLAGS;
    BashrcdTrue $NOFCFLAGS || FCFLAGS=$FFLAGS;
    BashrcdTrue $NOF77FLAGS || F77FLAGS=$FFLAGS;
    BashrcdTrue $NOFILTER_CXXFLAGS || FlagSub CXXFLAGS "${FLAG_FILTER_C_CXX[@]}" "${FLAG_FILTER_CXX_FORTRAN[@]}" "${FLAG_FILTER_CXXFLAGS[@]}";
    BashrcdTrue $NOFILTER_CFLAGS || FlagSub CFLAGS "${FLAG_FILTER_C_CXX[@]}" "${FLAG_FILTER_C_FORTRAN[@]}" "${FLAG_FILTER_CFLAGS[@]}";
    BashrcdTrue $NOFILTER_FFLAGS || FlagSub FFLAGS "${FLAG_FILTER_C_FORTRAN[@]}" "${FLAG_FILTER_CXX_FORTRAN[@]}" "${FLAG_FILTER_FORTRAN[@]}" "${FLAG_FILTER_FFLAGS[@]}";
    BashrcdTrue $NOFILTER_FCFLAGS || FlagSub FCFLAGS "${FLAG_FILTER_C_FORTRAN[@]}" "${FLAG_FILTER_CXX_FORTRAN[@]}" "${FLAG_FILTER_FORTRAN[@]}" "${FLAG_FILTER_FCFLAGS[@]}";
    BashrcdTrue $NOFILTER_F77FLAGS || FlagSub FCFLAGS "${FLAG_FILTER_C_FORTRAN[@]}" "${FLAG_FILTER_CXX_FORTRAN[@]}" "${FLAG_FILTER_FORTRAN[@]}" "${FLAG_FILTER_F77LAGS[@]}";
    ! BashrcdTrue $MESONDEDUP || FlagMesonDedup;
    unset OPTCFLAGS OPTCXXFLAGS OPTCPPFLAGS OPTLDFLAGS;
    unset NOLDOPT NOLDADD NOCOPT NOCXXOPT NOFFLAGS NOFCFLAGS NOF77FLAGS;
    unset NOFILTER_CXXFLAGS NOFILTER_CFLAGS;
    unset NOFILTER_FFLAGS NOFILTER_FCFLAGS NOFILTER_F77FLAGS
}
FlagSetGNU () 
{ 
    FlagSubAllFlags "${FLAG_FILTER_GNU[@]}"
}
FlagSetNonGNU () 
{ 
    : ${NOLDADD:=1};
    FlagSubAllFlags "${FLAG_FILTER_NONGNU[@]}";
    FlagReplaceAllFlags '-fstack-check*' '-fstack-check'
}
FlagSetUseNonGNU () 
{ 
    case $CC$CXX in 
        *clang*)
            return 0
        ;;
    esac;
    return 1
}
FlagSetup () 
{ 
    function FlagCompile () 
    { 
        :
    };
    local use_pgo;
    FlagSetFlags;
    if BashrcdTrue $PGO; then
        function FlagPreinst () 
        { 
            test -d "$PGO_DIR" || mkdir -p -m +1777 -- "$PGO_DIR" || { 
                eerror "cannot create pgo directory $PGO_DIR";
                die 'cannot create PGO_DIR';
                exit 2
            };
            ewarn "$CATEGORY/$PN will write profile info to world-writable";
            ewarn "$PGO_DIR";
            ewarn 'Reemerge it soon for an optimized version and removal of that directory'
        };
    else
        if BashrcdTrue $KEEPPGO; then
            function FlagPreinst () 
            { 
                :
            };
        else
            function FlagPreinst () 
            { 
                test -d "$PGO_DIR" || return 0;
                BashrcdLog "removing pgo directory $PGO_DIR";
                rm -r -f -- "$PGO_DIR" || { 
                    eerror "cannot remove pgo directory $PGO_DIR";
                    die 'cannot remove PGO_DIR';
                    exit 2
                };
                local g;
                g=${PGO_DIR%/*};
                [ -z "$g" ] || rmdir -p -- "$g" > /dev/null 2>&1
            };
        fi;
    fi;
    FlagInfoExport
}
FlagSub () 
{ 
    local subres subpat subf subvar sublist;
    subvar=$1;
    shift;
    subres=;
    eval sublist=\$$subvar;
    for subf in $sublist;
    do
        for subpat in "$@";
        do
            [ -n "${subpat:++}" ] || continue;
            case $subf in 
                $subpat)
                    subf=;
                    break
                ;;
            esac;
        done;
        [ -z "${subf:++}" ] || subres=$subres${subres:+\ }$subf;
    done;
    eval $subvar=\$subres
}
FlagSubAllFlags () 
{ 
    FlagSubCFlags "$@";
    FlagSub LDFLAGS "$@";
    FlagSub OPTLDFLAGS "$@";
    FlagSub FFLAGS "$@";
    FlagSub FCLAGS "$@";
    FlagSub F77LAGS "$@"
}
FlagSubCFlags () 
{ 
    FlagSub CFLAGS "$@";
    FlagSub CXXFLAGS "$@";
    FlagSub CPPFLAGS "$@";
    FlagSub OPTCFLAGS "$@";
    FlagSub OPTCXXFLAGS "$@";
    FlagSub OPTCPPFLAGS "$@"
}
LTOPatch () 
{ 
    if [[ -d $S ]]; then
        cd "${S}";
    else
        if ___eapi_has_S_WORKDIR_fallback; then
            cd "${WORKDIR}";
        else
            if [[ -z ${A} ]] && ! __has_phase_defined_up_to prepare; then
                cd "${WORKDIR}";
            else
                die "The source directory '${S}' doesn't exist";
            fi;
        fi;
    fi;
    local tagfile=${T}/.portage_lto_patches_applied;
    [[ -f ${tagfile} ]] && return;
     >> "${tagfile}";
    local lto_overlay_dir="$(portageq get_repo_path ${PORTAGE_CONFIGROOT} lto-overlay)";
    local basedir="${lto_overlay_dir%/}/sys-config/ltoize/files/patches";
    local applied d f;
    local -A _eapply_lto_patches;
    local prev_shopt=$(shopt -p nullglob);
    shopt -s nullglob;
    for d in "${basedir}"/${CATEGORY}/{${P}-${PR},${P},${PN}}{:${SLOT%/*},};
    do
        for f in "${d}"/*;
        do
            if [[ ( ${f} == *.diff || ${f} == *.patch ) && -z ${_eapply_lto_patches[${f##*/}]} ]]; then
                _eapply_lto_patches[${f##*/}]=${f};
            fi;
        done;
    done;
    local lto_patch_cmd;
    if [[ "${EAPI}" -ge 6 ]]; then
        lto_patch_cmd=eapply;
    else
        lto_patch_cmd=epatch;
    fi;
    if [[ ${#_eapply_lto_patches[@]} -gt 0 ]]; then
        while read -r -d '' f; do
            f=${_eapply_lto_patches[${f}]};
            if [[ -s ${f} ]]; then
                ${lto_patch_cmd} "${f}";
                applied=1;
            fi;
        done < <(printf -- '%s\0' "${!_eapply_lto_patches[@]}" |
			LC_ALL=C sort -z);
    fi;
    ${prev_shopt};
    [[ -n ${applied} ]] && ewarn "lto-overlay: LTO patches applied."
}
LocalePurge () 
{ 
    if BashrcdTrue $NOLOCALEPURGE || { 
        ! BashrcdTrue $LOCALEPURGE && ! BashrcdTrue $MANPURGE
    } || [ -z "${KEEP_LOCALES++}" ]; then
        return 0;
    fi;
    case $- in 
        *f*)
            LocalePurgeMain
        ;;
        *)
            set -f;
            LocalePurgeMain;
            set +f
        ;;
    esac
}
LocalePurgeMain () 
{ 
    local locale_list locale_item locale_cmd;
    locale_list=;
    for locale_item in $ALL_LOCALES ${ALL_LOCALES_ADD-};
    do
        [ -n "$locale_item" ] && LocalePurgeNokeep "$locale_item" && locale_list=$locale_list' '$locale_item;
    done;
    locale_cmd='for d
do	for l in $locale_list
do	if test -d "$d/$l$k"
then	rm -rvf -- "$d/$l"
fi
done
done';
    export locale_list;
    shell=`command -v sh` || shell=;
    : ${shell:=/bin/sh};
    if BashrcdTrue $LOCALEPURGE; then
        einfo 'removing undesired locales';
        find "$ED" -name locale -type d -exec "$shell" -c "k='/LC_MESSAGES'
$locale_cmd" sh '{}' '+';
    fi;
    if BashrcdTrue $MANPURGE; then
        einfo 'removing undesired manpages';
        find "$ED" -name man -type d -exec "$shell" -c "k=
$locale_cmd" sh '{}' '+';
    fi;
    unset locale_list
}
LocalePurgeNokeep () 
{ 
    local locale_keep;
    for locale_keep in $KEEP_LOCALES;
    do
        case $1 in 
            $locale_keep)
                return 1
            ;;
        esac;
    done
}
QlopSetup () 
{ 
    local num sec hour min date;
    command -v qlop > /dev/null 2>&1 || return 0;
    qlop -aH -- "$CATEGORY/$PN";
    qlop -tH -- "$CATEGORY/$PN";
    command -v title > /dev/null 2>&1 || return 0;
    num=$(tail -n1 /var/log/emerge.log | 		sed -e 's/^.*(\([0-9]*\) of \([0-9]*\)).*$/\1|\2/') && [ -n "$num" ] || { 
        date=$(date +%T);
        title "emerge $date $PN";
        return
    };
    sec=$(qlop -tCM -- "$CATEGORY/$PN" | 		sed -ne '/ [0-9][0-9]*$/{s/^.* \([0-9][0-9]*\)$/\1/;p;q}') && [ -n "$sec" ] || { 
        date=$(date +%T);
        title "emerge $date $num $PN";
        return
    };
    hour=$(( $sec / 3600 ));
    [ "$hour" -gt 0 ] || hour=;
    hour=$hour${hour:+:};
    sec=$(( $sec % 3600 ));
    min=$(( $sec / 60 ));
    sec=$(( $sec % 60 ));
    [ "$min" -gt 9 ] || min=0$min;
    [ "$sec" -gt 9 ] || sec=0$sec;
    date=$(date +%T);
    title "emerge $date $num $PN $hour$min:$sec"
}
Remove_la () 
{ 
    BashrcdTrue $NOLAFILEREMOVE && return;
    case "$CATEGORY/$PN" in 
        'media-libs/gst-plugins-base' | 'media-libs/libsidplay')
            return 0
        ;;
    esac;
    einfo 'removing unneeded *.la files';
    local shell;
    shell=`command -v sh` || shell=;
    : ${shell:=/bin/sh};
    Dexport=$ED find "$ED" -name '*.la' '!' -name 'libltdl.la' -exec "$shell" -c "for i
	do	if grep -q -- '^shouldnotlink=no\$' \"\$i\"
		then	printf '\\t%s\\n' \"\${i#\$Dexport}\"
			rm -- \"\$i\" || echo 'removing failed!'
		fi
	done" sh '{}' '+'
}
__eapi6_src_install () 
{ 
    if [[ -f Makefile || -f GNUmakefile || -f makefile ]]; then
        emake DESTDIR="${D}" install;
    fi;
    einstalldocs
}
__eapi6_src_prepare () 
{ 
    if ___is_indexed_array_var PATCHES; then
        [[ ${#PATCHES[@]} -gt 0 ]] && eapply "${PATCHES[@]}";
    else
        if [[ -n ${PATCHES} ]]; then
            eapply ${PATCHES};
        fi;
    fi;
    eapply_user
}
_at_uses_autoheader () 
{ 
    _at_uses_pkg A{C,M}_CONFIG_HEADER{S,}
}
_at_uses_automake () 
{ 
    _at_uses_pkg AM_INIT_AUTOMAKE
}
_at_uses_gettext () 
{ 
    _at_uses_pkg AM_GNU_GETTEXT_{,REQUIRE_}VERSION
}
_at_uses_glibgettext () 
{ 
    _at_uses_pkg AM_GLIB_GNU_GETTEXT
}
_at_uses_gnomedoc () 
{ 
    _at_uses_pkg GNOME_DOC_INIT
}
_at_uses_gtkdoc () 
{ 
    _at_uses_pkg GTK_DOC_CHECK
}
_at_uses_intltool () 
{ 
    _at_uses_pkg {AC,IT}_PROG_INTLTOOL
}
_at_uses_libltdl () 
{ 
    _at_uses_pkg LT_CONFIG_LTDL_DIR
}
_at_uses_libtool () 
{ 
    _at_uses_pkg A{C,M}_PROG_LIBTOOL LT_INIT
}
_at_uses_pkg () 
{ 
    if [[ -n $(autotools_check_macro "$@") ]]; then
        return 0;
    else
        local macro args=();
        for macro in "$@";
        do
            args+=(-e "^[[:space:]]*${macro}\>");
        done;
        egrep -q "${args[@]}" configure.??;
    fi
}
_autotools_m4dir_include () 
{ 
    local x include_opts flag;
    [[ ${WANT_AUTOCONF} == "2.1" ]] && flag="l" || flag="I";
    for x in "$@";
    do
        case ${x} in 
            -${flag})

            ;;
            *)
                [[ ! -d ${x} ]] && ewarn "autotools.eclass: '${x}' does not exist";
                include_opts+=" -${flag} ${x}"
            ;;
        esac;
    done;
    echo ${include_opts}
}
_check_build_dir () 
{ 
    : ${ECONF_SOURCE:=${S}};
    if [[ ! -n ${BUILD_DIR} && -n ${AUTOTOOLS_BUILD_DIR} ]]; then
        eqawarn "The AUTOTOOLS_BUILD_DIR variable has been renamed to BUILD_DIR.";
        eqawarn "Please migrate the ebuild to use the new one.";
        _RESPECT_AUTOTOOLS_BUILD_DIR=1;
    fi;
    if [[ -n ${_RESPECT_AUTOTOOLS_BUILD_DIR} ]]; then
        BUILD_DIR=${AUTOTOOLS_BUILD_DIR:-${WORKDIR}/${P}_build};
    else
        if [[ -n ${AUTOTOOLS_IN_SOURCE_BUILD} ]]; then
            : ${BUILD_DIR:=${ECONF_SOURCE}};
        else
            : ${BUILD_DIR:=${WORKDIR}/${P}_build};
        fi;
    fi;
    AUTOTOOLS_BUILD_DIR=${BUILD_DIR};
    echo ">>> Working in BUILD_DIR: \"${BUILD_DIR}\""
}
_clang_fullversion () 
{ 
    local ver="$1";
    shift;
    set -- $($(tc-getCPP "$@") -E -P - <<<"__clang_major__ __clang_minor__ __clang_patchlevel__");
    eval echo "$ver"
}
_elibtoolize () 
{ 
    local LIBTOOLIZE=${LIBTOOLIZE:-$(type -P glibtoolize > /dev/null && echo glibtoolize || echo libtoolize)};
    if [[ $1 == "--auto-ltdl" ]]; then
        shift;
        _at_uses_libltdl && set -- "$@" --ltdl;
    fi;
    [[ -f GNUmakefile.am || -f Makefile.am ]] && set -- "$@" --automake;
    autotools_run_tool ${LIBTOOLIZE} "$@"
}
_gcc-install-dir () 
{ 
    echo "$(LC_ALL=C $(tc-getCC) -print-search-dirs 2> /dev/null |		awk '$1=="install:" {print $2}')"
}
_gcc-specs-directive_raw () 
{ 
    local cc=$(tc-getCC);
    local specfiles=$(LC_ALL=C ${cc} -v 2>&1 | awk '$1=="Reading" {print $NF}');
    ${cc} -dumpspecs 2> /dev/null | cat - ${specfiles} | awk -v directive=$1 'BEGIN	{ pspec=""; spec=""; outside=1 }
$1=="*"directive":"  { pspec=spec; spec=""; outside=0; next }
	outside || NF==0 || ( substr($1,1,1)=="*" && substr($1,length($1),1)==":" ) { outside=1; next }
	spec=="" && substr($0,1,1)=="+" { spec=pspec " " substr($0,2); next }
	{ spec=spec $0 }
END	{ print spec }';
    return 0
}
_gcc-specs-exists () 
{ 
    [[ -f $(_gcc-install-dir)/$1 ]]
}
_gcc_fullversion () 
{ 
    local ver="$1";
    shift;
    set -- $($(tc-getCPP "$@") -E -P - <<<"__GNUC__ __GNUC_MINOR__ __GNUC_PATCHLEVEL__");
    eval echo "$ver"
}
_iconins () 
{ 
    ( insopts -m 0644;
    local funcname=$1;
    shift;
    local size dir;
    local context=apps;
    local theme=hicolor;
    while [[ $# -gt 0 ]]; do
        case $1 in 
            -s | --size)
                if [[ ${2%%x*}x${2%%x*} == "$2" ]]; then
                    size=${2%%x*};
                else
                    size=${2};
                fi;
                case ${size} in 
                    16 | 22 | 24 | 32 | 36 | 48 | 64 | 72 | 96 | 128 | 192 | 256 | 512)
                        size=${size}x${size}
                    ;;
                    scalable)

                    ;;
                    *)
                        eerror "${size} is an unsupported icon size!";
                        exit 1
                    ;;
                esac;
                shift 2
            ;;
            -t | --theme)
                theme=${2};
                shift 2
            ;;
            -c | --context)
                context=${2};
                shift 2
            ;;
            *)
                if [[ -z ${size} ]]; then
                    insinto /usr/share/pixmaps;
                else
                    insinto /usr/share/icons/${theme}/${size}/${context};
                fi;
                if [[ ${funcname} == doicon ]]; then
                    if [[ -f $1 ]]; then
                        doins "${1}";
                    else
                        if [[ -d $1 ]]; then
                            shopt -s nullglob;
                            doins "${1}"/*.{png,svg};
                            shopt -u nullglob;
                        else
                            eerror "${1} is not a valid file/directory!";
                            exit 1;
                        fi;
                    fi;
                else
                    break;
                fi;
                shift 1
            ;;
        esac;
    done;
    if [[ ${funcname} == newicon ]]; then
        newins "$@";
    fi ) || die
}
_multibuild_run () 
{ 
    local i=1;
    while [[ ${!i} == _* ]]; do
        (( i += 1 ));
    done;
    [[ ${i} -le ${#} ]] && einfo "${v}: running ${@:${i}}";
    "${@}"
}
_multilib_multibuild_wrapper () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local ABI=${MULTIBUILD_VARIANT#*.};
    local -r MULTILIB_ABI_FLAG=${MULTIBUILD_VARIANT%.*};
    multilib_toolchain_setup "${ABI}";
    readonly ABI;
    "${@}"
}
_tc-getPROG () 
{ 
    local tuple=$1;
    local v var vars=$2;
    local prog=($3);
    var=${vars%% *};
    for v in ${vars};
    do
        if [[ -n ${!v} ]]; then
            export ${var}="${!v}";
            echo "${!v}";
            return 0;
        fi;
    done;
    local search=;
    [[ -n $4 ]] && search=$(type -p $4-${prog[0]});
    [[ -z ${search} && -n ${!tuple} ]] && search=$(type -p ${!tuple}-${prog[0]});
    [[ -n ${search} ]] && prog[0]=${search##*/};
    export ${var}="${prog[*]}";
    echo "${!var}"
}
at_checksum () 
{ 
    find '(' -name 'Makefile.am' -o -name 'configure.ac' -o -name 'configure.in' ')' -exec cksum {} + | sort -k2
}
autotools-multilib_src_compile () 
{ 
    local _at_args=("${@}");
    multilib-minimal_src_compile
}
autotools-multilib_src_configure () 
{ 
    local _at_args=("${@}");
    multilib-minimal_src_configure
}
autotools-multilib_src_install () 
{ 
    local _at_args=("${@}");
    multilib-minimal_src_install
}
autotools-multilib_src_prepare () 
{ 
    autotools-utils_src_prepare "${@}";
    [[ -n ${AUTOTOOLS_IN_SOURCE_BUILD} ]] && multilib_copy_sources
}
autotools-multilib_src_test () 
{ 
    local _at_args=("${@}");
    multilib-minimal_src_test
}
autotools-utils_src_compile () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    _check_build_dir;
    pushd "${BUILD_DIR}" > /dev/null || die;
    emake "$@" || die 'emake failed';
    popd > /dev/null || die
}
autotools-utils_src_configure () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    [[ -z ${myeconfargs+1} || $(declare -p myeconfargs) == 'declare -a'* ]] || die 'autotools-utils.eclass: myeconfargs has to be an array.';
    local econfargs=();
    _check_build_dir;
    if "${ECONF_SOURCE}"/configure --help 2>&1 | grep -q '^ *--docdir='; then
        econfargs+=(--docdir="${EPREFIX}"/usr/share/doc/${PF});
    fi;
    if in_iuse static-libs; then
        econfargs+=(--enable-shared $(use_enable static-libs static));
    fi;
    econfargs+=("${myeconfargs[@]}");
    mkdir -p "${BUILD_DIR}" || die;
    pushd "${BUILD_DIR}" > /dev/null || die;
    econf "${econfargs[@]}" "$@";
    popd > /dev/null || die
}
autotools-utils_src_install () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    _check_build_dir;
    pushd "${BUILD_DIR}" > /dev/null || die;
    emake DESTDIR="${D}" "$@" install || die "emake install failed";
    popd > /dev/null || die;
    if declare -p DOCS &> /dev/null; then
        if [[ -n ${DOCS[@]} ]]; then
            dodoc -r "${DOCS[@]}";
        fi;
    else
        local f;
        for f in README* ChangeLog AUTHORS NEWS TODO CHANGES THANKS BUGS FAQ CREDITS CHANGELOG;
        do
            if [[ -s ${f} ]]; then
                dodoc "${f}" || die "(default) dodoc ${f} failed";
            fi;
        done;
    fi;
    if [[ -n ${HTML_DOCS} ]]; then
        dohtml -r "${HTML_DOCS[@]}" || die "dohtml failed";
    fi;
    local prune_ltfiles=${AUTOTOOLS_PRUNE_LIBTOOL_FILES};
    if [[ ${prune_ltfiles} != none ]]; then
        prune_libtool_files ${prune_ltfiles:+--${prune_ltfiles}};
    fi
}
autotools-utils_src_prepare () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    local want_autoreconf=${AUTOTOOLS_AUTORECONF};
    [[ -n ${PATCHES} ]] && epatch "${PATCHES[@]}";
    function at_checksum () 
    { 
        find '(' -name 'Makefile.am' -o -name 'configure.ac' -o -name 'configure.in' ')' -exec cksum {} + | sort -k2
    };
    [[ ! -n ${want_autoreconf} ]] && local checksum=$(at_checksum);
    epatch_user;
    if [[ ! -n ${want_autoreconf} ]]; then
        if [[ ${checksum} != $(at_checksum) ]]; then
            einfo 'Will autoreconfigure due to user patches applied.';
            want_autoreconf=yep;
        fi;
    fi;
    [[ -n ${want_autoreconf} ]] && eautoreconf;
    elibtoolize --patch-only
}
autotools-utils_src_test () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    _check_build_dir;
    pushd "${BUILD_DIR}" > /dev/null || die;
    if make -ni check "${@}" &> /dev/null; then
        emake check "${@}" || die 'emake check failed.';
    else
        if make -ni test "${@}" &> /dev/null; then
            emake test "${@}" || die 'emake test failed.';
        fi;
    fi;
    popd > /dev/null || die
}
autotools_check_macro () 
{ 
    [[ -f configure.ac || -f configure.in ]] || return 0;
    local trace_file=".__autoconf_trace_data";
    if [[ ! -e ${trace_file} ]] || [[ ! aclocal.m4 -ot ${trace_file} ]]; then
        WANT_AUTOCONF="2.5" autoconf $(autotools_m4dir_include) ${ALL_AUTOTOOLS_MACROS[@]/#/--trace=} > ${trace_file} 2> /dev/null;
    fi;
    local macro args=();
    for macro in "$@";
    do
        has ${macro} ${ALL_AUTOTOOLS_MACROS[@]} || die "internal error: add ${macro} to ALL_AUTOTOOLS_MACROS";
        args+=(-e ":${macro}:");
    done;
    grep "${args[@]}" ${trace_file}
}
autotools_check_macro_val () 
{ 
    local macro scan_out;
    for macro in "$@";
    do
        autotools_check_macro "${macro}" | gawk -v macro="${macro}" '($0 !~ /^[[:space:]]*(#|dnl)/) {
					if (match($0, macro ":(.*)$", res))
						print res[1]
				}' | uniq;
    done;
    return 0
}
autotools_env_setup () 
{ 
    if [[ ${WANT_AUTOMAKE} == "latest" ]]; then
        local pv;
        for pv in ${_LATEST_AUTOMAKE[@]/#*:};
        do
            local hv_args="";
            case ${EAPI:-0} in 
                5 | 6)
                    hv_args="--host-root"
                ;;
                7)
                    hv_args="-b"
                ;;
            esac;
            ROOT=/ has_version ${hv_args} "=sys-devel/automake-${pv}*" && export WANT_AUTOMAKE="${pv}" && break;
        done;
        [[ ${WANT_AUTOMAKE} == "latest" ]] && die "Cannot find the latest automake! Tried ${_LATEST_AUTOMAKE[*]}";
    fi;
    [[ ${WANT_AUTOCONF} == "latest" ]] && export WANT_AUTOCONF=2.5
}
autotools_m4dir_include () 
{ 
    _autotools_m4dir_include ${AT_M4DIR}
}
autotools_m4sysdir_include () 
{ 
    local paths=($(eval echo ${AT_SYS_M4DIR}));
    if [[ ${#paths[@]} -eq 0 && -n ${SYSROOT} ]]; then
        local path="${SYSROOT}/usr/share/aclocal";
        [[ -d ${path} ]] && paths+=("${path}");
    fi;
    _autotools_m4dir_include "${paths[@]}"
}
autotools_run_tool () 
{ 
    local autofail=true m4flags=false missing_ok=false return_output=false;
    while [[ -n $1 ]]; do
        case $1 in 
            --at-no-fail)
                autofail=false
            ;;
            --at-m4flags)
                m4flags=true
            ;;
            --at-missing)
                missing_ok=true
            ;;
            --at-output)
                return_output=true
            ;;
            *)
                break
            ;;
        esac;
        shift;
    done;
    if [[ ${EBUILD_PHASE} != "unpack" && ${EBUILD_PHASE} != "prepare" ]]; then
        ewarn "QA Warning: running $1 in ${EBUILD_PHASE} phase";
    fi;
    if ${missing_ok} && ! type -P ${1} > /dev/null; then
        einfo "Skipping '$*' due $1 not installed";
        return 0;
    fi;
    autotools_env_setup;
    local STDERR_TARGET="${T}/${1##*/}.out";
    if [[ -e ${STDERR_TARGET} ]]; then
        local i=1;
        while :; do
            STDERR_TARGET="${T}/${1##*/}-${i}.out";
            [[ -e ${STDERR_TARGET} ]] || break;
            : $(( i++ ));
        done;
    fi;
    if ${m4flags}; then
        set -- "${1}" $(autotools_m4dir_include) "${@:2}" $(autotools_m4sysdir_include);
    fi;
    if ${return_output}; then
        "$@";
        return;
    fi;
    printf "***** $1 *****\n***** PWD: ${PWD}\n***** $*\n\n" > "${STDERR_TARGET}";
    ebegin "Running $@";
    "$@" >> "${STDERR_TARGET}" 2>&1;
    if ! eend $? && ${autofail}; then
        echo;
        eerror "Failed Running $1 !";
        eerror;
        eerror "Include in your bugreport the contents of:";
        eerror;
        eerror "  ${STDERR_TARGET}";
        echo;
        die "Failed Running $1 !";
    fi
}
clang-fullversion () 
{ 
    _clang_fullversion '$1.$2.$3' "$@"
}
clang-major-version () 
{ 
    _clang_fullversion '$1' "$@"
}
clang-micro-version () 
{ 
    _clang_fullversion '$3' "$@"
}
clang-minor-version () 
{ 
    _clang_fullversion '$2' "$@"
}
clang-version () 
{ 
    _clang_fullversion '$1.$2' "$@"
}
config_rpath_update () 
{ 
    local dst src=$(type -P gettext | sed 's:bin/gettext:share/gettext/config.rpath:');
    [[ $# -eq 0 ]] && set -- $(find -name config.rpath);
    [[ $# -eq 0 ]] && return 0;
    einfo "Updating all config.rpath files";
    for dst in "$@";
    do
        einfo "   ${dst}";
        cp "${src}" "${dst}" || die;
    done
}
darwintoolize () 
{ 
    die "Use elibtoolize"
}
doicon () 
{ 
    _iconins ${FUNCNAME} "$@"
}
domenu () 
{ 
    ( local i ret=0;
    insopts -m 0644;
    insinto /usr/share/applications;
    for i in "$@";
    do
        if [[ -d ${i} ]]; then
            doins "${i}"/*.desktop;
            ((ret|=$?));
        else
            doins "${i}";
            ((ret|=$?));
        fi;
    done;
    exit ${ret} )
}
eaclocal () 
{ 
    [[ ! -f aclocal.m4 || -n $(grep -e 'generated.*by aclocal' aclocal.m4) ]] && autotools_run_tool --at-m4flags aclocal "$@" $(eaclocal_amflags)
}
eaclocal_amflags () 
{ 
    local aclocal_opts amflags_file;
    for amflags_file in GNUmakefile.am Makefile.am GNUmakefile.in Makefile.in;
    do
        [[ -e ${amflags_file} ]] || continue;
        autotools_env_setup;
        aclocal_opts=$(sed -n 			"/^ACLOCAL_AMFLAGS[[:space:]]*=/{ 			  # match the first line
			  s:[^=]*=::p; 			  # then gobble up all escaped lines
			  : nextline /\\\\$/{ n; p; b nextline; } 			}" ${amflags_file});
        eval aclocal_opts=\""${aclocal_opts}"\";
        break;
    done;
    echo ${aclocal_opts}
}
eautoconf () 
{ 
    if [[ ! -f configure.ac && ! -f configure.in ]]; then
        echo;
        eerror "No configure.{ac,in} present in '${PWD}'!";
        echo;
        die "No configure.{ac,in} present!";
    fi;
    if [[ ${WANT_AUTOCONF} != "2.1" && -e configure.in ]]; then
        eqawarn "This package has a configure.in file which has long been deprecated.  Please";
        eqawarn "update it to use configure.ac instead as newer versions of autotools will die";
        eqawarn "when it finds this file.  See https://bugs.gentoo.org/426262 for details.";
    fi;
    autotools_run_tool --at-m4flags autoconf "$@"
}
eautoheader () 
{ 
    _at_uses_autoheader || return 0;
    autotools_run_tool --at-no-fail --at-m4flags autoheader "$@"
}
eautomake () 
{ 
    local extra_opts=();
    local makefile_name;
    for makefile_name in {GNUmakefile,{M,m}akefile}.am "";
    do
        [[ -f ${makefile_name} ]] && break;
    done;
    function _automake_version () 
    { 
        autotools_run_tool --at-output automake --version 2> /dev/null | sed -n -e '1{s:.*(GNU automake) ::p;q}'
    };
    if [[ -z ${makefile_name} ]]; then
        _at_uses_automake || return 0;
    else
        if [[ -z ${FROM_EAUTORECONF} && -f ${makefile_name%.am}.in ]]; then
            local used_automake;
            local installed_automake;
            installed_automake=$(WANT_AUTOMAKE= _automake_version);
            used_automake=$(head -n 1 < ${makefile_name%.am}.in | 			sed -e 's:.*by automake \(.*\) from .*:\1:');
            if [[ ${installed_automake} != ${used_automake} ]]; then
                ewarn "Automake used for the package (${used_automake}) differs from" "the installed version (${installed_automake}).";
                ewarn "Forcing a full rebuild of the autotools to workaround.";
                eautoreconf;
                return 0;
            fi;
        fi;
    fi;
    [[ -f INSTALL && -f AUTHORS && -f ChangeLog && -f NEWS && -f README ]] || extra_opts+=(--foreign);
    case $(_automake_version) in 
        1.4 | 1.4[.-]*)

        ;;
        *)
            extra_opts+=(--force-missing)
        ;;
    esac;
    autotools_run_tool automake --add-missing --copy "${extra_opts[@]}" "$@"
}
eautopoint () 
{ 
    autotools_run_tool autopoint "$@"
}
eautoreconf () 
{ 
    local x g;
    if [[ -z ${AT_NO_RECURSIVE} ]]; then
        for x in $(autotools_check_macro_val AC_CONFIG_SUBDIRS);
        do
            if [[ -d ${x} ]]; then
                pushd "${x}" > /dev/null;
                AT_NOELIBTOOLIZE="yes" eautoreconf || die;
                popd > /dev/null;
            fi;
        done;
    fi;
    einfo "Running eautoreconf in '${PWD}' ...";
    local m4dirs=$(autotools_check_macro_val AC_CONFIG_{AUX,MACRO}_DIR);
    [[ -n ${m4dirs} ]] && mkdir -p ${m4dirs};
    local i tools=(glibgettext false "autotools_run_tool glib-gettextize --copy --force" gettext false "autotools_run_tool --at-missing autopoint --force" intltool false "autotools_run_tool intltoolize --automake --copy --force" gtkdoc false "autotools_run_tool --at-missing gtkdocize --copy" gnomedoc false "autotools_run_tool --at-missing gnome-doc-prepare --copy --force" libtool false "_elibtoolize --auto-ltdl --install --copy --force");
    for ((i = 0; i < ${#tools[@]}; i += 3 ))
    do
        if _at_uses_${tools[i]}; then
            tools[i+1]=true;
            ${tools[i+2]};
        fi;
    done;
    local rerun_aclocal=false;
    eaclocal;
    for ((i = 0; i < ${#tools[@]}; i += 3 ))
    do
        if ! ${tools[i+1]} && _at_uses_${tools[i]}; then
            ${tools[i+2]};
            rerun_aclocal=true;
        fi;
    done;
    ${rerun_aclocal} && eaclocal;
    if [[ ${WANT_AUTOCONF} = 2.1 ]]; then
        eautoconf;
    else
        eautoconf --force;
    fi;
    eautoheader;
    [[ ${AT_NOEAUTOMAKE} != "yes" ]] && FROM_EAUTORECONF="yes" eautomake ${AM_OPTS};
    if [[ ${AT_NOELIBTOOLIZE} != "yes" ]]; then
        elibtoolize --force "${PWD}";
    fi;
    return 0
}
ebeep () 
{ 
    ewarn "QA Notice: ebeep is not defined in EAPI=${EAPI}, please file a bug at https://bugs.gentoo.org"
}
econf_build () 
{ 
    local CBUILD=${CBUILD:-${CHOST}};
    tc-env_build econf --build=${CBUILD} --host=${CBUILD} "$@"
}
ecvs_clean () 
{ 
    [[ $# -eq 0 ]] && set -- .;
    find "$@" '(' -type d -name 'CVS' -prune -o -type f -name '.cvs*' ')' -exec rm -rf '{}' +
}
edos2unix () 
{ 
    [[ $# -eq 0 ]] && return 0;
    sed -i 's/\r$//' -- "$@" || die
}
egit_clean () 
{ 
    [[ $# -eq 0 ]] && set -- .;
    find "$@" -type d -name '.git*' -prune -exec rm -rf '{}' +
}
einstalldocs () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local dodoc_opts=-r;
    has ${EAPI} 0 1 2 3 && dodoc_opts=;
    if ! declare -p DOCS &> /dev/null; then
        local d;
        for d in README* ChangeLog AUTHORS NEWS TODO CHANGES THANKS BUGS FAQ CREDITS CHANGELOG;
        do
            if [[ -s ${d} ]]; then
                dodoc "${d}" || die;
            fi;
        done;
    else
        if [[ $(declare -p DOCS) == "declare -a"* ]]; then
            if [[ -n ${DOCS[@]} ]]; then
                dodoc ${dodoc_opts} "${DOCS[@]}" || die;
            fi;
        else
            if [[ -n ${DOCS} ]]; then
                dodoc ${dodoc_opts} ${DOCS} || die;
            fi;
        fi;
    fi;
    if [[ $(declare -p HTML_DOCS 2>/dev/null) == "declare -a"* ]]; then
        if [[ -n ${HTML_DOCS[@]} ]]; then
            dohtml -r "${HTML_DOCS[@]}" || die;
        fi;
    else
        if [[ -n ${HTML_DOCS} ]]; then
            dohtml -r ${HTML_DOCS} || die;
        fi;
    fi;
    return 0
}
elibtoolize () 
{ 
    type -P eltpatch &> /dev/null || die "eltpatch not found; is app-portage/elt-patches installed?";
    ELT_LOGDIR=${T} LD=$(tc-getLD) eltpatch "${@}" || die "eltpatch failed"
}
emktemp () 
{ 
    local exe="touch";
    [[ $1 == -d ]] && exe="mkdir" && shift;
    local topdir=$1;
    if [[ -z ${topdir} ]]; then
        [[ -z ${T} ]] && topdir="/tmp" || topdir=${T};
    fi;
    if ! type -P mktemp > /dev/null; then
        local tmp=/;
        while [[ -e ${tmp} ]]; do
            tmp=${topdir}/tmp.${RANDOM}.${RANDOM}.${RANDOM};
        done;
        ${exe} "${tmp}" || ${exe} -p "${tmp}";
        echo "${tmp}";
    else
        if [[ ${exe} == "touch" ]]; then
            TMPDIR="${topdir}" mktemp -t tmp.XXXXXXXXXX;
        else
            TMPDIR="${topdir}" mktemp -dt tmp.XXXXXXXXXX;
        fi;
    fi
}
epatch () 
{ 
    function _epatch_draw_line () 
    { 
        [[ -z $1 ]] && set "$(printf "%65s" '')";
        echo "${1//?/=}"
    };
    unset P4CONFIG P4PORT P4USER;
    local EPATCH_OPTS=(${EPATCH_OPTS[*]});
    while [[ $# -gt 0 ]]; do
        case $1 in 
            -*)
                EPATCH_OPTS+=("$1")
            ;;
            *)
                break
            ;;
        esac;
        shift;
    done;
    if [[ $# -gt 1 ]]; then
        local m;
        for m in "$@";
        do
            epatch "${m}";
        done;
        return 0;
    fi;
    local SINGLE_PATCH="no";
    [[ $# -eq 0 ]] && set -- "${EPATCH_SOURCE}";
    if [[ -f $1 ]]; then
        SINGLE_PATCH="yes";
        set -- "$1";
        local EPATCH_SUFFIX=$1;
    else
        if [[ -d $1 ]]; then
            evar_push_set LC_COLLATE C;
            set -- "$1"/*${EPATCH_SUFFIX:+."${EPATCH_SUFFIX}"};
            evar_pop;
        else
            if [[ -f ${EPATCH_SOURCE}/$1 ]]; then
                epatch "${EPATCH_SOURCE}/$1";
                return $?;
            else
                [[ $# -ne 0 ]] && EPATCH_SOURCE=$1;
                echo;
                eerror "Cannot find \$EPATCH_SOURCE!  Value for \$EPATCH_SOURCE is:";
                eerror;
                eerror "  ${EPATCH_SOURCE}";
                eerror "  ( ${EPATCH_SOURCE##*/} )";
                echo;
                die "Cannot find \$EPATCH_SOURCE!";
            fi;
        fi;
    fi;
    EPATCH_OPTS="${EPATCH_COMMON_OPTS} ${EPATCH_OPTS[*]}";
    local PIPE_CMD;
    case ${EPATCH_SUFFIX##*\.} in 
        xz)
            PIPE_CMD="xz -dc"
        ;;
        lzma)
            PIPE_CMD="lzma -dc"
        ;;
        bz2)
            PIPE_CMD="bzip2 -dc"
        ;;
        gz | Z | z)
            PIPE_CMD="gzip -dc"
        ;;
        ZIP | zip)
            PIPE_CMD="unzip -p"
        ;;
        *)

        ;;
    esac;
    [[ ${SINGLE_PATCH} == "no" ]] && einfo "${EPATCH_MULTI_MSG}";
    local x;
    for x in "$@";
    do
        [[ ! -f ${x} ]] && continue;
        local patchname=${x##*/};
        local a=${patchname#*_};
        a=${a%%_*};
        if ! [[ ${SINGLE_PATCH} == "yes" || ${EPATCH_FORCE} == "yes" || ${a} == all || ${a} == ${ARCH} ]]; then
            continue;
        fi;
        if [[ -n ${EPATCH_EXCLUDE}${EPATCH_USER_EXCLUDE} ]]; then
            local prev_noglob=$(shopt -p -o noglob);
            set -o noglob;
            local ex;
            for ex in ${EPATCH_EXCLUDE};
            do
                if [[ ${patchname} == ${ex} ]]; then
                    einfo "  Skipping ${patchname} due to EPATCH_EXCLUDE ...";
                    ${prev_noglob};
                    continue 2;
                fi;
            done;
            for ex in ${EPATCH_USER_EXCLUDE};
            do
                if [[ ${patchname} == ${ex} ]]; then
                    einfo "  Skipping ${patchname} due to EPATCH_USER_EXCLUDE ...";
                    ${prev_noglob};
                    continue 2;
                fi;
            done;
            ${prev_noglob};
        fi;
        if [[ ${SINGLE_PATCH} == "yes" ]]; then
            if [[ -n ${EPATCH_SINGLE_MSG} ]]; then
                einfo "${EPATCH_SINGLE_MSG}";
            else
                einfo "Applying ${patchname} ...";
            fi;
        else
            einfo "  ${patchname} ...";
        fi;
        local patch="patch";
        eval $(alias patch 2>/dev/null | sed 's:^alias ::');
        local STDERR_TARGET="${T}/${patchname}.out";
        if [[ -e ${STDERR_TARGET} ]]; then
            STDERR_TARGET="${T}/${patchname}-$$.out";
        fi;
        printf "***** %s *****\nPWD: %s\nPATCH TOOL: %s -> %s\nVERSION INFO:\n%s\n\n" "${patchname}" "${PWD}" "${patch}" "$(type -P "${patch}")" "$(${patch} --version)" > "${STDERR_TARGET}";
        local count=0;
        local PATCH_TARGET;
        if [[ -n ${PIPE_CMD} ]]; then
            PATCH_TARGET="${T}/$$.patch";
            echo "PIPE_COMMAND:  ${PIPE_CMD} ${x} > ${PATCH_TARGET}" >> "${STDERR_TARGET}";
            if ! ( ${PIPE_CMD} "${x}" > "${PATCH_TARGET}" ) >> "${STDERR_TARGET}" 2>&1; then
                echo;
                eerror "Could not extract patch!";
                count=5;
                break;
            fi;
        else
            PATCH_TARGET=${x};
        fi;
        local abs_paths=$(egrep -n '^[-+]{3} /' "${PATCH_TARGET}" | awk '$2 != "/dev/null" { print }');
        if [[ -n ${abs_paths} ]]; then
            count=1;
            printf "NOTE: skipping -p0 due to absolute paths in patch:\n%s\n" "${abs_paths}" >> "${STDERR_TARGET}";
        fi;
        local rel_paths=$(egrep -n '^[-+]{3} [^	]*[.][.]/' "${PATCH_TARGET}");
        if [[ -n ${rel_paths} ]]; then
            echo;
            eerror "Rejected Patch: ${patchname} !";
            eerror " ( ${PATCH_TARGET} )";
            eerror;
            eerror "Your patch uses relative paths '../':";
            eerror "${rel_paths}";
            echo;
            die "you need to fix the relative paths in patch";
        fi;
        local patch_cmd;
        while [[ ${count} -lt 5 ]]; do
            patch_cmd="${patch} -p${count} ${EPATCH_OPTS}";
            ( _epatch_draw_line "***** ${patchname} *****";
            echo;
            echo "PATCH COMMAND:  ${patch_cmd} --dry-run -f < '${PATCH_TARGET}'";
            echo;
            _epatch_draw_line "***** ${patchname} *****";
            ${patch_cmd} --dry-run -f < "${PATCH_TARGET}" 2>&1;
            ret=$?;
            echo;
            echo "patch program exited with status ${ret}";
            exit ${ret} ) >> "${STDERR_TARGET}";
            if [ $? -eq 0 ]; then
                ( _epatch_draw_line "***** ${patchname} *****";
                echo;
                echo "ACTUALLY APPLYING ${patchname} ...";
                echo "PATCH COMMAND:  ${patch_cmd} < '${PATCH_TARGET}'";
                echo;
                _epatch_draw_line "***** ${patchname} *****";
                ${patch_cmd} < "${PATCH_TARGET}" 2>&1;
                ret=$?;
                echo;
                echo "patch program exited with status ${ret}";
                exit ${ret} ) >> "${STDERR_TARGET}";
                if [ $? -ne 0 ]; then
                    echo;
                    eerror "A dry-run of patch command succeeded, but actually";
                    eerror "applying the patch failed!";
                    count=5;
                fi;
                break;
            fi;
            : $(( count++ ));
        done;
        (( EPATCH_N_APPLIED_PATCHES++ ));
        if [[ -n ${PIPE_CMD} ]]; then
            rm -f "${PATCH_TARGET}";
        fi;
        if [[ ${count} -ge 5 ]]; then
            echo;
            eerror "Failed Patch: ${patchname} !";
            eerror " ( ${PATCH_TARGET} )";
            eerror;
            eerror "Include in your bugreport the contents of:";
            eerror;
            eerror "  ${STDERR_TARGET}";
            echo;
            die "Failed Patch: ${patchname}!";
        fi;
        rm -f "${STDERR_TARGET}";
        cat <<-EOF >> "${T}/epatch.log"
PATCH: ${x}
CMD: ${patch_cmd}
PWD: ${PWD}

EOF

        eend 0;
    done;
    [[ ${SINGLE_PATCH} == "no" ]] && einfo "Done with patching";
    :
}
epatch_user () 
{ 
    [[ $# -ne 0 ]] && die "epatch_user takes no options";
    local applied="${T}/epatch_user.log";
    [[ -e ${applied} ]] && return 2;
    local EPATCH_SOURCE check;
    for check in ${CATEGORY}/{${P}-${PR},${P},${PN}}{,:${SLOT%/*}};
    do
        EPATCH_SOURCE=${EPATCH_USER_SOURCE}/${CTARGET}/${check};
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${EPATCH_USER_SOURCE}/${CHOST}/${check};
        [[ -r ${EPATCH_SOURCE} ]] || EPATCH_SOURCE=${EPATCH_USER_SOURCE}/${check};
        if [[ -d ${EPATCH_SOURCE} ]]; then
            local old_n_applied_patches=${EPATCH_N_APPLIED_PATCHES:-0};
            EPATCH_SOURCE=${EPATCH_SOURCE} EPATCH_SUFFIX="patch" EPATCH_FORCE="yes" EPATCH_MULTI_MSG="Applying user patches from ${EPATCH_SOURCE} ..." epatch;
            echo "${EPATCH_SOURCE}" > "${applied}";
            if [[ ${old_n_applied_patches} -lt ${EPATCH_N_APPLIED_PATCHES} ]]; then
                has epatch_user_death_notice ${EBUILD_DEATH_HOOKS} || EBUILD_DEATH_HOOKS+=" epatch_user_death_notice";
            fi;
            return 0;
        fi;
    done;
    echo "none" > "${applied}";
    return 1
}
epatch_user_death_notice () 
{ 
    ewarn "!!! User patches were applied to this build!"
}
epause () 
{ 
    ewarn "QA Notice: epause is not defined in EAPI=${EAPI}, please file a bug at https://bugs.gentoo.org"
}
eshopts_pop () 
{ 
    local s;
    estack_pop eshopts s || die "${FUNCNAME}: unbalanced push";
    eval "${s}" || die "${FUNCNAME}: sanity: invalid shopt options: ${s}"
}
eshopts_push () 
{ 
    if [[ $1 == -[su] ]]; then
        estack_push eshopts "$(shopt -p)";
        [[ $# -eq 0 ]] && return 0;
        shopt "$@" || die "${FUNCNAME}: bad options to shopt: $*";
    else
        estack_push eshopts "$(shopt -p -o)";
        [[ $# -eq 0 ]] && return 0;
        set "$@" || die "${FUNCNAME}: bad options to set: $*";
    fi
}
estack_pop () 
{ 
    [[ $# -eq 0 || $# -gt 2 ]] && die "estack_pop: incorrect # of arguments";
    local _estack_name="_ESTACK_$1_";
    shift;
    local _estack_retvar=$1;
    shift;
    eval local _estack_i=\${#${_estack_name}\[@\]};
    [[ $(( --_estack_i )) -eq -1 ]] && return 1;
    if [[ -n ${_estack_retvar} ]]; then
        eval ${_estack_retvar}=\"\${${_estack_name}\[${_estack_i}\]}\";
    fi;
    eval unset \"${_estack_name}\[${_estack_i}\]\"
}
estack_push () 
{ 
    [[ $# -eq 0 ]] && die "estack_push: incorrect # of arguments";
    local stack_name="_ESTACK_$1_";
    shift;
    eval ${stack_name}+=\( \"\$@\" \)
}
esvn_clean () 
{ 
    [[ $# -eq 0 ]] && set -- .;
    find "$@" -type d -name '.svn' -prune -exec rm -rf '{}' +
}
eumask_pop () 
{ 
    [[ $# -eq 0 ]] || die "${FUNCNAME}: we take no options";
    local s;
    estack_pop eumask s || die "${FUNCNAME}: unbalanced push";
    umask ${s} || die "${FUNCNAME}: sanity: could not restore umask: ${s}"
}
eumask_push () 
{ 
    estack_push eumask "$(umask)";
    umask "$@" || die "${FUNCNAME}: bad options to umask: $*"
}
evar_pop () 
{ 
    local cnt=${1:-bad};
    case $# in 
        0)
            cnt=1
        ;;
        1)
            isdigit "${cnt}" || die "${FUNCNAME}: first arg must be a number: $*"
        ;;
        *)
            die "${FUNCNAME}: only accepts one arg: $*"
        ;;
    esac;
    local var val;
    while (( cnt-- )); do
        estack_pop evar val || die "${FUNCNAME}: unbalanced push";
        estack_pop evar var || die "${FUNCNAME}: unbalanced push";
        [[ ${val} == "unset_76fc3c462065bb4ca959f939e6793f94" ]] && unset ${var} || printf -v "${var}" '%s' "${val}";
    done
}
evar_push () 
{ 
    local var val;
    for var in "$@";
    do
        [[ ${!var+set} == "set" ]] && val=${!var} || val="unset_76fc3c462065bb4ca959f939e6793f94";
        estack_push evar "${var}" "${val}";
    done
}
evar_push_set () 
{ 
    local var=$1;
    evar_push ${var};
    case $# in 
        1)
            unset ${var}
        ;;
        2)
            printf -v "${var}" '%s' "$2"
        ;;
        *)
            die "${FUNCNAME}: incorrect # of args: $*"
        ;;
    esac
}
gcc-fullversion () 
{ 
    _gcc_fullversion '$1.$2.$3' "$@"
}
gcc-major-version () 
{ 
    _gcc_fullversion '$1' "$@"
}
gcc-micro-version () 
{ 
    _gcc_fullversion '$3' "$@"
}
gcc-minor-version () 
{ 
    _gcc_fullversion '$2' "$@"
}
gcc-specs-directive () 
{ 
    local directive subdname subdirective;
    directive="$(_gcc-specs-directive_raw $1)";
    while [[ ${directive} == *%\(*\)* ]]; do
        subdname=${directive/*%\(};
        subdname=${subdname/\)*};
        subdirective="$(_gcc-specs-directive_raw ${subdname})";
        directive="${directive//\%(${subdname})/${subdirective}}";
    done;
    echo "${directive}";
    return 0
}
gcc-specs-nostrict () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    [[ "${directive/\{!fstrict-overflow:}" != "${directive}" ]]
}
gcc-specs-now () 
{ 
    local directive;
    directive=$(gcc-specs-directive link_command);
    [[ "${directive/\{!nonow:}" != "${directive}" ]]
}
gcc-specs-pie () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    [[ "${directive/\{!nopie:}" != "${directive}" ]]
}
gcc-specs-relro () 
{ 
    local directive;
    directive=$(gcc-specs-directive link_command);
    [[ "${directive/\{!norelro:}" != "${directive}" ]]
}
gcc-specs-ssp () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    [[ "${directive/\{!fno-stack-protector:}" != "${directive}" ]]
}
gcc-specs-ssp-to-all () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    [[ "${directive/\{!fno-stack-protector-all:}" != "${directive}" ]]
}
gcc-specs-stack-check () 
{ 
    local directive;
    directive=$(gcc-specs-directive cc1);
    [[ "${directive/\{!fno-stack-check:}" != "${directive}" ]]
}
gcc-version () 
{ 
    _gcc_fullversion '$1.$2' "$@"
}
gen_usr_ldscript () 
{ 
    local lib libdir=$(get_libdir) output_format="" auto=false suffix=$(get_libname);
    [[ -z ${ED+set} ]] && local ED=${D%/}${EPREFIX}/;
    tc-is-static-only && return;
    if [[ $(type -t multilib_is_native_abi) == "function" ]]; then
        multilib_is_native_abi || return 0;
    fi;
    case ${CTARGET:-${CHOST}} in 
        *-darwin*)

        ;;
        *-android*)
            return 0
        ;;
        *linux* | *-freebsd* | *-openbsd* | *-netbsd*)
            use prefix && return 0
        ;;
        *)
            return 0
        ;;
    esac;
    dodir /usr/${libdir};
    if [[ $1 == "-a" ]]; then
        auto=true;
        shift;
        dodir /${libdir};
    fi;
    local flags=(${CFLAGS} ${LDFLAGS} -Wl,--verbose);
    if $(tc-getLD) --version | grep -q 'GNU gold'; then
        local d="${T}/bfd-linker";
        mkdir -p "${d}";
        ln -sf $(which ${CHOST}-ld.bfd) "${d}"/ld;
        flags+=(-B"${d}");
    fi;
    output_format=$($(tc-getCC) "${flags[@]}" 2>&1 | sed -n 's/^OUTPUT_FORMAT("\([^"]*\)",.*/\1/p');
    [[ -n ${output_format} ]] && output_format="OUTPUT_FORMAT ( ${output_format} )";
    for lib in "$@";
    do
        local tlib;
        if ${auto}; then
            lib="lib${lib}${suffix}";
        else
            [[ -r ${ED}/${libdir}/${lib} ]] || continue;
        fi;
        case ${CTARGET:-${CHOST}} in 
            *-darwin*)
                if ${auto}; then
                    tlib=$(scanmacho -qF'%S#F' "${ED}"/usr/${libdir}/${lib});
                else
                    tlib=$(scanmacho -qF'%S#F' "${ED}"/${libdir}/${lib});
                fi;
                [[ -z ${tlib} ]] && die "unable to read install_name from ${lib}";
                tlib=${tlib##*/};
                if ${auto}; then
                    mv "${ED}"/usr/${libdir}/${lib%${suffix}}.*${suffix#.} "${ED}"/${libdir}/ || die;
                    if [[ ${tlib} != ${lib%${suffix}}.*${suffix#.} ]]; then
                        mv "${ED}"/usr/${libdir}/${tlib%${suffix}}.*${suffix#.} "${ED}"/${libdir}/ || die;
                    fi;
                    rm -f "${ED}"/${libdir}/${lib};
                fi;
                if [[ ! -w "${ED}/${libdir}/${tlib}" ]]; then
                    chmod u+w "${ED}${libdir}/${tlib}";
                    local nowrite=yes;
                fi;
                install_name_tool -id "${EPREFIX}"/${libdir}/${tlib} "${ED}"/${libdir}/${tlib} || die "install_name_tool failed";
                [[ -n ${nowrite} ]] && chmod u-w "${ED}${libdir}/${tlib}";
                pushd "${ED}/usr/${libdir}" > /dev/null;
                ln -snf "../../${libdir}/${tlib}" "${lib}";
                popd > /dev/null
            ;;
            *)
                if ${auto}; then
                    tlib=$(scanelf -qF'%S#F' "${ED}"/usr/${libdir}/${lib});
                    [[ -z ${tlib} ]] && die "unable to read SONAME from ${lib}";
                    mv "${ED}"/usr/${libdir}/${lib}* "${ED}"/${libdir}/ || die;
                    if [[ ${tlib} != ${lib}* ]]; then
                        mv "${ED}"/usr/${libdir}/${tlib}* "${ED}"/${libdir}/ || die;
                    fi;
                    rm -f "${ED}"/${libdir}/${lib};
                else
                    tlib=${lib};
                fi;
                cat > "${ED}/usr/${libdir}/${lib}" <<-END_LDSCRIPT
/* GNU ld script
   Since Gentoo has critical dynamic libraries in /lib, and the static versions
   in /usr/lib, we need to have a "fake" dynamic lib in /usr/lib, otherwise we
   run into linking problems.  This "fake" dynamic lib is a linker script that
   redirects the linker to the real lib.  And yes, this works in the cross-
   compiling scenario as the sysroot-ed linker will prepend the real path.

   See bug https://bugs.gentoo.org/4411 for more info.
 */
${output_format}
GROUP ( ${EPREFIX}/${libdir}/${tlib} )
END_LDSCRIPT

            ;;
        esac
        fperms a+x "/usr/${libdir}/${lib}" || die "could not change perms on ${lib}";
    done
}
get_abi_CFLAGS () 
{ 
    get_abi_var CFLAGS "$@"
}
get_abi_CHOST () 
{ 
    get_abi_var CHOST "$@"
}
get_abi_CTARGET () 
{ 
    get_abi_var CTARGET "$@"
}
get_abi_FAKE_TARGETS () 
{ 
    get_abi_var FAKE_TARGETS "$@"
}
get_abi_LDFLAGS () 
{ 
    get_abi_var LDFLAGS "$@"
}
get_abi_LIBDIR () 
{ 
    get_abi_var LIBDIR "$@"
}
get_abi_var () 
{ 
    local flag=$1;
    local abi=${2:-${ABI:-${DEFAULT_ABI:-default}}};
    local var="${flag}_${abi}";
    echo ${!var}
}
get_all_abis () 
{ 
    local x order="" mvar dvar;
    mvar="MULTILIB_ABIS";
    dvar="DEFAULT_ABI";
    if [[ -n $1 ]]; then
        mvar="$1_${mvar}";
        dvar="$1_${dvar}";
    fi;
    if [[ -z ${!mvar} ]]; then
        echo "default";
        return 0;
    fi;
    for x in ${!mvar};
    do
        if [[ ${x} != ${!dvar} ]]; then
            order="${order:+${order} }${x}";
        fi;
    done;
    order="${order:+${order} }${!dvar}";
    echo ${order};
    return 0
}
get_all_libdirs () 
{ 
    local libdirs abi;
    for abi in ${MULTILIB_ABIS};
    do
        libdirs+=" $(get_abi_LIBDIR ${abi})";
    done;
    [[ " ${libdirs} " != *" lib "* ]] && libdirs+=" lib";
    echo "${libdirs}"
}
get_exeext () 
{ 
    case ${CHOST} in 
        *-cygwin* | mingw* | *-mingw*)
            echo ".exe"
        ;;
    esac
}
get_install_abis () 
{ 
    local x order="";
    if [[ -z ${MULTILIB_ABIS} ]]; then
        echo "default";
        return 0;
    fi;
    if [[ ${EMULTILIB_PKG} == "true" ]]; then
        for x in ${MULTILIB_ABIS};
        do
            if [[ ${x} != "${DEFAULT_ABI}" ]]; then
                has ${x} ${ABI_DENY} || order="${order} ${x}";
            fi;
        done;
        has ${DEFAULT_ABI} ${ABI_DENY} || order="${order} ${DEFAULT_ABI}";
        if [[ -n ${ABI_ALLOW} ]]; then
            local ordera="";
            for x in ${order};
            do
                if has ${x} ${ABI_ALLOW}; then
                    ordera="${ordera} ${x}";
                fi;
            done;
            order=${ordera};
        fi;
    else
        order=${DEFAULT_ABI};
    fi;
    if [[ -z ${order} ]]; then
        die "The ABI list is empty.  Are you using a proper multilib profile?  Perhaps your USE flags or MULTILIB_ABIS are too restrictive for this package.";
    fi;
    echo ${order};
    return 0
}
get_libdir () 
{ 
    local CONF_LIBDIR;
    if [ -n "${CONF_LIBDIR_OVERRIDE}" ]; then
        echo ${CONF_LIBDIR_OVERRIDE};
    else
        get_abi_LIBDIR;
    fi
}
get_libname () 
{ 
    local libname;
    local ver=$1;
    case ${CHOST} in 
        *-cygwin*)
            libname="dll.a"
        ;;
        mingw* | *-mingw*)
            libname="dll"
        ;;
        *-darwin*)
            libname="dylib"
        ;;
        *-mint*)
            libname="irrelevant"
        ;;
        hppa*-hpux*)
            libname="sl"
        ;;
        *)
            libname="so"
        ;;
    esac;
    if [[ -z $* ]]; then
        echo ".${libname}";
    else
        for ver in "$@";
        do
            case ${CHOST} in 
                *-cygwin*)
                    echo ".${ver}.${libname}"
                ;;
                *-darwin*)
                    echo ".${ver}.${libname}"
                ;;
                *-mint*)
                    echo ".${libname}"
                ;;
                *)
                    echo ".${libname}.${ver}"
                ;;
            esac;
        done;
    fi
}
get_modname () 
{ 
    local modname;
    local ver=$1;
    case ${CHOST} in 
        *-darwin*)
            modname="bundle"
        ;;
        *)
            modname="so"
        ;;
    esac;
    echo ".${modname}"
}
has_multilib_profile () 
{ 
    [ -n "${MULTILIB_ABIS}" -a "${MULTILIB_ABIS}" != "${MULTILIB_ABIS/ /}" ]
}
in_iuse () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${#} -eq 1 ]] || die "Invalid args to ${FUNCNAME}()";
    local flag=${1};
    local liuse=(${IUSE});
    has "${flag}" "${liuse[@]#[+-]}"
}
is_final_abi () 
{ 
    has_multilib_profile || return 0;
    set -- $(get_install_abis);
    local LAST_ABI=$#;
    [[ ${!LAST_ABI} == ${ABI} ]]
}
isdigit () 
{ 
    local d;
    for d in "$@";
    do
        [[ ${d:-bad} == *[!0-9]* ]] && return 1;
    done;
    return 0
}
make_desktop_entry () 
{ 
    [[ -z $1 ]] && die "make_desktop_entry: You must specify the executable";
    local exec=${1};
    local name=${2:-${PN}};
    local icon=${3:-${PN}};
    local type=${4};
    local fields=${5};
    if [[ -z ${type} ]]; then
        local catmaj=${CATEGORY%%-*};
        local catmin=${CATEGORY##*-};
        case ${catmaj} in 
            app)
                case ${catmin} in 
                    accessibility)
                        type="Utility;Accessibility"
                    ;;
                    admin)
                        type=System
                    ;;
                    antivirus)
                        type=System
                    ;;
                    arch)
                        type="Utility;Archiving"
                    ;;
                    backup)
                        type="Utility;Archiving"
                    ;;
                    cdr)
                        type="AudioVideo;DiscBurning"
                    ;;
                    dicts)
                        type="Office;Dictionary"
                    ;;
                    doc)
                        type=Documentation
                    ;;
                    editors)
                        type="Utility;TextEditor"
                    ;;
                    emacs)
                        type="Development;TextEditor"
                    ;;
                    emulation)
                        type="System;Emulator"
                    ;;
                    laptop)
                        type="Settings;HardwareSettings"
                    ;;
                    office)
                        type=Office
                    ;;
                    pda)
                        type="Office;PDA"
                    ;;
                    vim)
                        type="Development;TextEditor"
                    ;;
                    xemacs)
                        type="Development;TextEditor"
                    ;;
                esac
            ;;
            dev)
                type="Development"
            ;;
            games)
                case ${catmin} in 
                    action | fps)
                        type=ActionGame
                    ;;
                    arcade)
                        type=ArcadeGame
                    ;;
                    board)
                        type=BoardGame
                    ;;
                    emulation)
                        type=Emulator
                    ;;
                    kids)
                        type=KidsGame
                    ;;
                    puzzle)
                        type=LogicGame
                    ;;
                    roguelike)
                        type=RolePlaying
                    ;;
                    rpg)
                        type=RolePlaying
                    ;;
                    simulation)
                        type=Simulation
                    ;;
                    sports)
                        type=SportsGame
                    ;;
                    strategy)
                        type=StrategyGame
                    ;;
                esac;
                type="Game;${type}"
            ;;
            gnome)
                type="Gnome;GTK"
            ;;
            kde)
                type="KDE;Qt"
            ;;
            mail)
                type="Network;Email"
            ;;
            media)
                case ${catmin} in 
                    gfx)
                        type=Graphics
                    ;;
                    *)
                        case ${catmin} in 
                            radio)
                                type=Tuner
                            ;;
                            sound)
                                type=Audio
                            ;;
                            tv)
                                type=TV
                            ;;
                            video)
                                type=Video
                            ;;
                        esac;
                        type="AudioVideo;${type}"
                    ;;
                esac
            ;;
            net)
                case ${catmin} in 
                    dialup)
                        type=Dialup
                    ;;
                    ftp)
                        type=FileTransfer
                    ;;
                    im)
                        type=InstantMessaging
                    ;;
                    irc)
                        type=IRCClient
                    ;;
                    mail)
                        type=Email
                    ;;
                    news)
                        type=News
                    ;;
                    nntp)
                        type=News
                    ;;
                    p2p)
                        type=FileTransfer
                    ;;
                    voip)
                        type=Telephony
                    ;;
                esac;
                type="Network;${type}"
            ;;
            sci)
                case ${catmin} in 
                    astro*)
                        type=Astronomy
                    ;;
                    bio*)
                        type=Biology
                    ;;
                    calc*)
                        type=Calculator
                    ;;
                    chem*)
                        type=Chemistry
                    ;;
                    elec*)
                        type=Electronics
                    ;;
                    geo*)
                        type=Geology
                    ;;
                    math*)
                        type=Math
                    ;;
                    physics)
                        type=Physics
                    ;;
                    visual*)
                        type=DataVisualization
                    ;;
                esac;
                type="Education;Science;${type}"
            ;;
            sys)
                type="System"
            ;;
            www)
                case ${catmin} in 
                    client)
                        type=WebBrowser
                    ;;
                esac;
                type="Network;${type}"
            ;;
            *)
                type=
            ;;
        esac;
    fi;
    local slot=${SLOT%/*};
    if [[ ${slot} == "0" ]]; then
        local desktop_name="${PN}";
    else
        local desktop_name="${PN}-${slot}";
    fi;
    local desktop="${T}/$(echo ${exec} | sed 's:[[:space:]/:]:_:g')-${desktop_name}.desktop";
    type=${type%;}${type:+;};
    if [[ -n ${icon} && ${icon} != /* ]] && [[ ${icon} == *.xpm || ${icon} == *.png || ${icon} == *.svg ]]; then
        ewarn "As described in the Icon Theme Specification, icon file extensions are not";
        ewarn "allowed in .desktop files if the value is not an absolute path.";
        icon=${icon%.*};
    fi;
    cat <<-EOF > "${desktop}" || 
[Desktop Entry]
Name=${name}
Type=Application
Comment=${DESCRIPTION}
Exec=${exec}
TryExec=${exec%% *}
Icon=${icon}
Categories=${type}
EOF
 die
    if [[ ${fields:-=} != *=* ]]; then
        ewarn "make_desktop_entry: update your 5th arg to read Path=${fields}";
        fields="Path=${fields}";
    fi;
    if [[ -n ${fields} ]]; then
        printf '%b\n' "${fields}" >> "${desktop}" || die;
    fi;
    ( insopts -m 0644;
    insinto /usr/share/applications;
    doins "${desktop}" ) || die "installing desktop file failed"
}
make_session_desktop () 
{ 
    [[ -z $1 ]] && eerror "$0: You must specify the title" && return 1;
    [[ -z $2 ]] && eerror "$0: You must specify the command" && return 1;
    local title=$1;
    local command=$2;
    local desktop=${T}/${wm:-${PN}}.desktop;
    shift 2;
    cat <<-EOF > "${desktop}" || 
[Desktop Entry]
Name=${title}
Comment=This session logs you into ${title}
Exec=${command} $*
TryExec=${command}
Type=XSession
EOF
 die
    ( insopts -m 0644;
    insinto /usr/share/xsessions;
    doins "${desktop}" )
}
make_wrapper () 
{ 
    local wrapper=$1 bin=$2 chdir=$3 libdir=$4 path=$5;
    local tmpwrapper=$(emktemp);
    has "${EAPI:-0}" 0 1 2 && local EPREFIX="";
    ( echo '#!/bin/sh';
    if [[ -n ${libdir} ]]; then
        local var;
        if [[ ${CHOST} == *-darwin* ]]; then
            var=DYLD_LIBRARY_PATH;
        else
            var=LD_LIBRARY_PATH;
        fi;
        cat <<-EOF
if [ "\${${var}+set}" = "set" ] ; then
export ${var}="\${${var}}:${EPREFIX}${libdir}"
else
export ${var}="${EPREFIX}${libdir}"
fi
EOF

    fi
    [[ -n ${chdir} ]] && printf 'cd "%s" &&\n' "${EPREFIX}${chdir}";
    printf 'exec %s "$@"\n' "${bin/#\//${EPREFIX}/}" ) > "${tmpwrapper}";
    chmod go+rx "${tmpwrapper}";
    if [[ -n ${path} ]]; then
        ( exeopts -m 0755;
        exeinto "${path}";
        newexe "${tmpwrapper}" "${wrapper}" ) || die;
    else
        newbin "${tmpwrapper}" "${wrapper}" || die;
    fi
}
multibuild_copy_sources () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local _MULTIBUILD_INITIAL_BUILD_DIR=${BUILD_DIR:-${S}};
    einfo "Will copy sources from ${_MULTIBUILD_INITIAL_BUILD_DIR}";
    local cp_args=();
    if cp --reflink=auto --version &> /dev/null; then
        cp_args+=(--reflink=auto);
    fi;
    function _multibuild_create_source_copy () 
    { 
        einfo "${MULTIBUILD_VARIANT}: copying to ${BUILD_DIR}";
        cp -p -R "${cp_args[@]}" "${_MULTIBUILD_INITIAL_BUILD_DIR}" "${BUILD_DIR}" || die
    };
    multibuild_foreach_variant _multibuild_create_source_copy
}
multibuild_for_best_variant () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ -n ${MULTIBUILD_VARIANTS} ]] || die "MULTIBUILD_VARIANTS need to be set";
    local MULTIBUILD_VARIANTS=("${MULTIBUILD_VARIANTS[$(( ${#MULTIBUILD_VARIANTS[@]} - 1 ))]}");
    multibuild_foreach_variant "${@}"
}
multibuild_foreach_variant () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ -n ${MULTIBUILD_VARIANTS} ]] || die "MULTIBUILD_VARIANTS need to be set";
    local bdir=${BUILD_DIR:-${S}};
    [[ ${bdir%%/} == ${WORKDIR%%/} ]] && bdir=${WORKDIR}/build;
    local prev_id=${MULTIBUILD_ID:+${MULTIBUILD_ID}-};
    local ret=0 lret=0 v;
    debug-print "${FUNCNAME}: initial build_dir = ${bdir}";
    for v in "${MULTIBUILD_VARIANTS[@]}";
    do
        local MULTIBUILD_VARIANT=${v};
        local MULTIBUILD_ID=${prev_id}${v};
        local BUILD_DIR=${bdir%%/}-${v};
        function _multibuild_run () 
        { 
            local i=1;
            while [[ ${!i} == _* ]]; do
                (( i += 1 ));
            done;
            [[ ${i} -le ${#} ]] && einfo "${v}: running ${@:${i}}";
            "${@}"
        };
        _multibuild_run "${@}" > >(exec tee -a "${T}/build-${MULTIBUILD_ID}.log") 2>&1;
        lret=${?};
    done;
    [[ ${ret} -eq 0 && ${lret} -ne 0 ]] && ret=${lret};
    return ${ret}
}
multibuild_merge_root () 
{ 
    local src=${1};
    local dest=${2};
    local ret;
    if use userland_BSD; then
        tar -C "${src}" -f - -c . | tar -x -f - -C "${dest}";
        [[ ${PIPESTATUS[*]} == '0 0' ]];
        ret=${?};
    else
        local cp_args=();
        if cp -a --version &> /dev/null; then
            cp_args+=(-a);
        else
            cp_args+=(-P -R -p);
        fi;
        if cp --reflink=auto --version &> /dev/null; then
            cp_args+=(--reflink=auto);
        fi;
        cp "${cp_args[@]}" "${src}"/. "${dest}"/;
        ret=${?};
    fi;
    if [[ ${ret} -ne 0 ]]; then
        die "${MULTIBUILD_VARIANT:-(unknown)}: merging image failed.";
    fi;
    rm -rf "${src}"
}
multibuild_parallel_foreach_variant () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${EAPI} == [45] ]] || die "${FUNCNAME} is banned in EAPI ${EAPI}";
    multibuild_foreach_variant "${@}"
}
multilib-minimal_abi_src_configure () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    mkdir -p "${BUILD_DIR}" || die;
    pushd "${BUILD_DIR}" > /dev/null || die;
    if declare -f multilib_src_configure > /dev/null; then
        multilib_src_configure;
    else
        default_src_configure;
    fi;
    popd > /dev/null || die
}
multilib-minimal_src_compile () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    function multilib-minimal_abi_src_compile () 
    { 
        debug-print-function ${FUNCNAME} "$@";
        pushd "${BUILD_DIR}" > /dev/null || die;
        if declare -f multilib_src_compile > /dev/null; then
            multilib_src_compile;
        else
            default_src_compile;
        fi;
        popd > /dev/null || die
    };
    multilib_foreach_abi multilib-minimal_abi_src_compile
}
multilib-minimal_src_configure () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    function multilib-minimal_abi_src_configure () 
    { 
        debug-print-function ${FUNCNAME} "$@";
        mkdir -p "${BUILD_DIR}" || die;
        pushd "${BUILD_DIR}" > /dev/null || die;
        if declare -f multilib_src_configure > /dev/null; then
            multilib_src_configure;
        else
            default_src_configure;
        fi;
        popd > /dev/null || die
    };
    multilib_foreach_abi multilib-minimal_abi_src_configure
}
multilib-minimal_src_install () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    function multilib-minimal_abi_src_install () 
    { 
        debug-print-function ${FUNCNAME} "$@";
        pushd "${BUILD_DIR}" > /dev/null || die;
        if declare -f multilib_src_install > /dev/null; then
            multilib_src_install;
        else
            if [[ -f Makefile || -f GNUmakefile || -f makefile ]]; then
                emake DESTDIR="${D}" install;
            fi;
        fi;
        multilib_prepare_wrappers;
        multilib_check_headers;
        popd > /dev/null || die
    };
    multilib_foreach_abi multilib-minimal_abi_src_install;
    multilib_install_wrappers;
    if declare -f multilib_src_install_all > /dev/null; then
        multilib_src_install_all;
    else
        einstalldocs;
    fi
}
multilib-minimal_src_test () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    function multilib-minimal_abi_src_test () 
    { 
        debug-print-function ${FUNCNAME} "$@";
        pushd "${BUILD_DIR}" > /dev/null || die;
        if declare -f multilib_src_test > /dev/null; then
            multilib_src_test;
        else
            default_src_test;
        fi;
        popd > /dev/null || die
    };
    multilib_foreach_abi multilib-minimal_abi_src_test
}
multilib_build_binaries () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${EAPI} == [45] ]] || die "${FUNCNAME} is banned in EAPI ${EAPI}, use multilib_is_native_abi() instead";
    eqawarn "QA warning: multilib_build_binaries is deprecated. Please use the equivalent";
    eqawarn "multilib_is_native_abi function instead.";
    multilib_is_native_abi "${@}"
}
multilib_check_headers () 
{ 
    function _multilib_header_cksum () 
    { 
        set -o pipefail;
        if [[ -d ${ED%/}/usr/include ]]; then
            find "${ED%/}"/usr/include -type f -exec cksum {} + | sort -k2;
        fi
    };
    local cksum cksum_prev;
    local cksum_file=${T}/.multilib_header_cksum;
    cksum=$(_multilib_header_cksum) || die;
    unset -f _multilib_header_cksum;
    if [[ -f ${cksum_file} ]]; then
        cksum_prev=$(< "${cksum_file}") || die;
        if [[ ${cksum} != ${cksum_prev} ]]; then
            echo "${cksum}" > "${cksum_file}.new" || die;
            eerror "Header files have changed between ABIs.";
            if type -p diff &> /dev/null; then
                eerror "$(diff -du "${cksum_file}" "${cksum_file}.new")";
            else
                eerror "Old checksums in: ${cksum_file}";
                eerror "New checksums in: ${cksum_file}.new";
            fi;
            die "Header checksum mismatch, aborting.";
        fi;
    else
        echo "${cksum}" > "${cksum_file}" || die;
    fi
}
multilib_copy_sources () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local MULTIBUILD_VARIANTS=($(multilib_get_enabled_abi_pairs));
    multibuild_copy_sources
}
multilib_env () 
{ 
    local CTARGET=${1:-${CTARGET}};
    local cpu=${CTARGET%%*-};
    case ${cpu} in 
        aarch64*)
            export CFLAGS_arm=${CFLAGS_arm-};
            case ${cpu} in 
                aarch64*be)
                    export CHOST_arm="armv8b-${CTARGET#*-}"
                ;;
                *)
                    export CHOST_arm="armv8l-${CTARGET#*-}"
                ;;
            esac;
            CHOST_arm=${CHOST_arm/%-gnu/-gnueabi};
            export CTARGET_arm=${CHOST_arm};
            export LIBDIR_arm="lib";
            export CFLAGS_arm64=${CFLAGS_arm64-};
            export CHOST_arm64=${CTARGET};
            export CTARGET_arm64=${CHOST_arm64};
            export LIBDIR_arm64="lib64";
            : ${MULTILIB_ABIS=arm64};
            : ${DEFAULT_ABI=arm64}
        ;;
        x86_64*)
            export CFLAGS_x86=${CFLAGS_x86--m32};
            export CHOST_x86=${CTARGET/x86_64/i686};
            CHOST_x86=${CHOST_x86/%-gnux32/-gnu};
            export CTARGET_x86=${CHOST_x86};
            if [[ ${SYMLINK_LIB} == "yes" ]]; then
                export LIBDIR_x86="lib32";
            else
                export LIBDIR_x86="lib";
            fi;
            export CFLAGS_amd64=${CFLAGS_amd64--m64};
            export CHOST_amd64=${CTARGET/%-gnux32/-gnu};
            export CTARGET_amd64=${CHOST_amd64};
            export LIBDIR_amd64="lib64";
            export CFLAGS_x32=${CFLAGS_x32--mx32};
            export CHOST_x32=${CTARGET/%-gnu/-gnux32};
            export CTARGET_x32=${CHOST_x32};
            export LIBDIR_x32="libx32";
            case ${CTARGET} in 
                *-gnux32)
                    : ${MULTILIB_ABIS=x32 amd64 x86};
                    : ${DEFAULT_ABI=x32}
                ;;
                *)
                    : ${MULTILIB_ABIS=amd64 x86};
                    : ${DEFAULT_ABI=amd64}
                ;;
            esac
        ;;
        mips64* | mipsisa64*)
            export CFLAGS_o32=${CFLAGS_o32--mabi=32};
            export CHOST_o32=${CTARGET/mips64/mips};
            export CHOST_o32=${CHOST_o32/mipsisa64/mipsisa32};
            export CTARGET_o32=${CHOST_o32};
            export LIBDIR_o32="lib";
            export CFLAGS_n32=${CFLAGS_n32--mabi=n32};
            export CHOST_n32=${CTARGET};
            export CTARGET_n32=${CHOST_n32};
            export LIBDIR_n32="lib32";
            export CFLAGS_n64=${CFLAGS_n64--mabi=64};
            export CHOST_n64=${CTARGET};
            export CTARGET_n64=${CHOST_n64};
            export LIBDIR_n64="lib64";
            : ${MULTILIB_ABIS=n64 n32 o32};
            : ${DEFAULT_ABI=n32}
        ;;
        powerpc64*)
            export CFLAGS_ppc=${CFLAGS_ppc--m32};
            export CHOST_ppc=${CTARGET/powerpc64/powerpc};
            export CTARGET_ppc=${CHOST_ppc};
            export LIBDIR_ppc="lib";
            export CFLAGS_ppc64=${CFLAGS_ppc64--m64};
            export CHOST_ppc64=${CTARGET};
            export CTARGET_ppc64=${CHOST_ppc64};
            export LIBDIR_ppc64="lib64";
            : ${MULTILIB_ABIS=ppc64 ppc};
            : ${DEFAULT_ABI=ppc64}
        ;;
        riscv64*)
            export CFLAGS_lp64d=${CFLAGS_lp64d--mabi=lp64d};
            export CHOST_lp64d=${CTARGET};
            export CTARGET_lp64d=${CTARGET};
            export LIBDIR_lp64d="lib64/lp64d";
            export CFLAGS_lp64=${CFLAGS_lp64--mabi=lp64};
            export CHOST_lp64=${CTARGET};
            export CTARGET_lp64=${CTARGET};
            export LIBDIR_lp64="lib64/lp64";
            : ${MULTILIB_ABIS=lp64d lp64};
            : ${DEFAULT_ABI=lp64d}
        ;;
        s390x*)
            export CFLAGS_s390=${CFLAGS_s390--m31};
            export CHOST_s390=${CTARGET/s390x/s390};
            export CTARGET_s390=${CHOST_s390};
            export LIBDIR_s390="lib";
            export CFLAGS_s390x=${CFLAGS_s390x--m64};
            export CHOST_s390x=${CTARGET};
            export CTARGET_s390x=${CHOST_s390x};
            export LIBDIR_s390x="lib64";
            : ${MULTILIB_ABIS=s390x s390};
            : ${DEFAULT_ABI=s390x}
        ;;
        sparc64*)
            export CFLAGS_sparc32=${CFLAGS_sparc32--m32};
            export CHOST_sparc32=${CTARGET/sparc64/sparc};
            export CTARGET_sparc32=${CHOST_sparc32};
            export LIBDIR_sparc32="lib";
            export CFLAGS_sparc64=${CFLAGS_sparc64--m64};
            export CHOST_sparc64=${CTARGET};
            export CTARGET_sparc64=${CHOST_sparc64};
            export LIBDIR_sparc64="lib64";
            : ${MULTILIB_ABIS=sparc64 sparc32};
            : ${DEFAULT_ABI=sparc64}
        ;;
        *)
            : ${MULTILIB_ABIS=default};
            : ${DEFAULT_ABI=default}
        ;;
    esac;
    export MULTILIB_ABIS DEFAULT_ABI
}
multilib_for_best_abi () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${EAPI} == [45] ]] || die "${FUNCNAME} is banned in EAPI ${EAPI}, use multilib_is_native_abi() instead";
    eqawarn "QA warning: multilib_for_best_abi() function is deprecated and should";
    eqawarn "not be used. The multilib_is_native_abi() check may be used instead.";
    local MULTIBUILD_VARIANTS=($(multilib_get_enabled_abi_pairs));
    multibuild_for_best_variant _multilib_multibuild_wrapper "${@}"
}
multilib_foreach_abi () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local MULTIBUILD_VARIANTS=($(multilib_get_enabled_abi_pairs));
    multibuild_foreach_variant _multilib_multibuild_wrapper "${@}"
}
multilib_get_enabled_abi_pairs () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local abis=($(get_all_abis));
    local abi i found;
    for abi in "${abis[@]}";
    do
        for i in "${_MULTILIB_FLAGS[@]}";
        do
            local m_abis=${i#*:} m_abi;
            local m_flag=${i%:*};
            for m_abi in ${m_abis//,/ };
            do
                if [[ ${m_abi} == ${abi} ]] && { 
                    [[ ! -n "${MULTILIB_COMPAT[@]}" ]] || has "${m_flag}" "${MULTILIB_COMPAT[@]}"
                } && use "${m_flag}"; then
                    echo "${m_flag}.${abi}";
                    found=1;
                    break 2;
                fi;
            done;
        done;
    done;
    if [[ ! -n ${found} ]]; then
        local abi=${ABI:-${DEFAULT_ABI}};
        debug-print "${FUNCNAME}: no ABIs enabled, fallback to ${abi}";
        debug-print "${FUNCNAME}: ABI=${ABI}, DEFAULT_ABI=${DEFAULT_ABI}";
        echo ".${abi}";
    fi
}
multilib_get_enabled_abis () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local pairs=($(multilib_get_enabled_abi_pairs));
    echo "${pairs[@]#*.}"
}
multilib_install_wrappers () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${#} -le 1 ]] || die "${FUNCNAME}: too many arguments";
    [[ ${COMPLETE_MULTILIB} == yes ]] && return;
    local root=${1:-${ED}};
    if [[ -d ${ED%/}/tmp/multilib-include ]]; then
        multibuild_merge_root "${ED%/}"/tmp/multilib-include "${root}"/usr/include;
        rmdir "${ED%/}"/tmp &> /dev/null;
    fi
}
multilib_is_native_abi () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${#} -eq 0 ]] || die "${FUNCNAME}: too many arguments";
    [[ ${COMPLETE_MULTILIB} == yes || ${ABI} == ${DEFAULT_ABI} ]]
}
multilib_native_enable () 
{ 
    if multilib_is_native_abi; then
        echo "--enable-${1}${2+=${2}}";
    else
        echo "--disable-${1}";
    fi
}
multilib_native_use_enable () 
{ 
    if multilib_is_native_abi; then
        use_enable "${@}";
    else
        echo "--disable-${2:-${1}}";
    fi
}
multilib_native_use_with () 
{ 
    if multilib_is_native_abi; then
        use_with "${@}";
    else
        echo "--without-${2:-${1}}";
    fi
}
multilib_native_usex () 
{ 
    if multilib_is_native_abi; then
        usex "${@}";
    else
        echo "${3-no}${5}";
    fi
}
multilib_native_with () 
{ 
    if multilib_is_native_abi; then
        echo "--with-${1}${2+=${2}}";
    else
        echo "--without-${1}";
    fi
}
multilib_parallel_foreach_abi () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local MULTIBUILD_VARIANTS=($(multilib_get_enabled_abi_pairs));
    multibuild_foreach_variant _multilib_multibuild_wrapper "${@}"
}
multilib_prepare_wrappers () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    [[ ${#} -le 1 ]] || die "${FUNCNAME}: too many arguments";
    local root=${1:-${ED%/}};
    local f;
    if [[ ${COMPLETE_MULTILIB} == yes ]]; then
        for f in "${MULTILIB_CHOST_TOOLS[@]}";
        do
            f=${f#/};
            local dir=${f%/*};
            local fn=${f##*/};
            ln -s "${fn}" "${root}/${dir}/${CHOST}-${fn}" || die;
        done;
        return;
    fi;
    for f in "${MULTILIB_CHOST_TOOLS[@]}";
    do
        f=${f#/};
        local dir=${f%/*};
        local fn=${f##*/};
        if [[ -L ${root}/${f} ]]; then
            local target;
            target=$(readlink "${root}/${f}") || die;
            local target_dir target_fn=${target##*/};
            [[ ${target} == */* ]] && target_dir=${target%/*};
            ln -f -s "${target_dir+${target_dir}/}${CHOST}-${target_fn}" "${root}/${f}" || die;
        fi;
        mv "${root}/${f}" "${root}/${dir}/${CHOST}-${fn}" || die;
        if multilib_is_native_abi; then
            ln -s "${CHOST}-${fn}" "${root}/${f}" || die;
        fi;
    done;
    if [[ -n ${MULTILIB_WRAPPED_HEADERS[@]} ]]; then
        if [[ -n ${MULTILIB_ABI_FLAG} ]]; then
            for f in "${MULTILIB_WRAPPED_HEADERS[@]}";
            do
                f=${f#/};
                if [[ ${f} != usr/include/* ]]; then
                    die "Wrapping headers outside of /usr/include is not supported at the moment.";
                fi;
                f=${f#usr/include};
                local dir=${f%/*};
                if [[ -f ${root}/usr/include${f} ]]; then
                    local wrapper=${ED%/}/tmp/multilib-include${f};
                    if [[ ! -f ${ED%/}/tmp/multilib-include${f} ]]; then
                        dodir "/tmp/multilib-include${dir}";
                        cat > "${wrapper}" <<_EOF_ || 
/* This file is auto-generated by multilib-build.eclass
 * as a multilib-friendly wrapper. For the original content,
 * please see the files that are #included below.
 */

#if defined(__x86_64__) /* amd64 */
#	if defined(__ILP32__) /* x32 ABI */
#		error "abi_x86_x32 not supported by the package."
#	else /* 64-bit ABI */
#		error "abi_x86_64 not supported by the package."
#	endif
#elif defined(__i386__) /* plain x86 */
#	error "abi_x86_32 not supported by the package."
#elif defined(__mips__)
#	if(_MIPS_SIM == _ABIN32) /* n32 */
#		error "abi_mips_n32 not supported by the package."
#	elif(_MIPS_SIM == _ABI64) /* n64 */
#		error "abi_mips_n64 not supported by the package."
#	elif(_MIPS_SIM == _ABIO32) /* o32 */
#		error "abi_mips_o32 not supported by the package."
#	endif
#elif defined(__riscv)
#	if defined(__riscv_float_abi_double)
#		error "abi_riscv_lp64d not supported by the package."
#	elif defined(__riscv_float_abi_single)
#		error "abi_riscv_lp64f not supported by the package."
#	else
#		error "abi_riscv_lp64 not supported by the package."
#	endif
#elif defined(__sparc__)
#	if defined(__arch64__)
#		error "abi_sparc_64 not supported by the package."
#	else
#		error "abi_sparc_32 not supported by the package."
#	endif
#elif defined(__s390__)
#	if defined(__s390x__)
#		error "abi_s390_64 not supported by the package."
#	else
#		error "abi_s390_32 not supported by the package."
#	endif
#elif defined(__powerpc__) || defined(__ppc__)
#	if defined(__powerpc64__) || defined(__ppc64__)
#		error "abi_ppc_64 not supported by the package."
#	else
#		error "abi_ppc_32 not supported by the package."
#	endif
#elif defined(SWIG) /* https://sourceforge.net/p/swig/bugs/799/ */
#	error "Native ABI not supported by the package."
#else
#	error "No ABI matched, please report a bug to bugs.gentoo.org"
#endif
_EOF_
 die;
                    fi
                    if ! grep -q "${MULTILIB_ABI_FLAG} " "${wrapper}"; then
                        die "Flag ${MULTILIB_ABI_FLAG} not listed in wrapper template. Please report a bug to https://bugs.gentoo.org.";
                    fi;
                    dodir "/tmp/multilib-include/${CHOST}${dir}";
                    mv "${root}/usr/include${f}" "${ED%/}/tmp/multilib-include/${CHOST}${dir}/" || die;
                    sed -e "/${MULTILIB_ABI_FLAG} /s&error.*&include <${CHOST}${f}>&" -i "${wrapper}" || die;
                    if multilib_is_native_abi; then
                        sed -e "/Native ABI/s&error.*&include <${CHOST}${f}>&" -i "${wrapper}" || die;
                    fi;
                fi;
            done;
        fi;
    fi
}
multilib_src_compile () 
{ 
    emake "${_at_args[@]}"
}
multilib_src_configure () 
{ 
    [[ -n ${AUTOTOOLS_IN_SOURCE_BUILD} ]] && local ECONF_SOURCE=${BUILD_DIR};
    autotools-utils_src_configure "${_at_args[@]}"
}
multilib_src_install () 
{ 
    emake DESTDIR="${D}" "${_at_args[@]}" install
}
multilib_src_install_all () 
{ 
    einstalldocs;
    local prune_ltfiles=${AUTOTOOLS_PRUNE_LIBTOOL_FILES};
    if [[ ${prune_ltfiles} != none ]]; then
        prune_libtool_files ${prune_ltfiles:+--${prune_ltfiles}};
    fi
}
multilib_src_test () 
{ 
    autotools-utils_src_test "${_at_args[@]}"
}
multilib_toolchain_setup () 
{ 
    local v vv;
    export ABI=$1;
    if [[ ${_DEFAULT_ABI_SAVED} == "true" ]]; then
        for v in CHOST CBUILD AS CC CXX F77 FC LD PKG_CONFIG_{LIBDIR,PATH};
        do
            vv="_abi_saved_${v}";
            [[ ${!vv+set} == "set" ]] && export ${v}="${!vv}" || unset ${v};
            unset ${vv};
        done;
        unset _DEFAULT_ABI_SAVED;
    fi;
    if [[ ${ABI} != ${DEFAULT_ABI} ]]; then
        for v in CHOST CBUILD AS CC CXX F77 FC LD PKG_CONFIG_{LIBDIR,PATH};
        do
            vv="_abi_saved_${v}";
            [[ ${!v+set} == "set" ]] && export ${vv}="${!v}" || unset ${vv};
        done;
        export _DEFAULT_ABI_SAVED="true";
        if [[ ${CBUILD} == "${CHOST}" ]]; then
            export CBUILD=$(get_abi_CHOST $1);
        fi;
        export CHOST=$(get_abi_CHOST ${DEFAULT_ABI});
        export CC="$(tc-getCC) $(get_abi_CFLAGS)";
        export CXX="$(tc-getCXX) $(get_abi_CFLAGS)";
        export F77="$(tc-getF77) $(get_abi_CFLAGS)";
        export FC="$(tc-getFC) $(get_abi_CFLAGS)";
        export LD="$(tc-getLD) $(get_abi_LDFLAGS)";
        export CHOST=$(get_abi_CHOST $1);
        export PKG_CONFIG_LIBDIR=${EPREFIX}/usr/$(get_libdir)/pkgconfig;
        export PKG_CONFIG_PATH=${EPREFIX}/usr/share/pkgconfig;
    fi
}
newicon () 
{ 
    _iconins ${FUNCNAME} "$@"
}
newmenu () 
{ 
    ( insopts -m 0644;
    insinto /usr/share/applications;
    newins "$@" )
}
number_abis () 
{ 
    set -- `get_install_abis`;
    echo $#
}
optfeature () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    local i j msg;
    local desc=$1;
    local flag=0;
    shift;
    for i in "$@";
    do
        for j in ${i};
        do
            if has_version "${j}"; then
                flag=1;
            else
                flag=0;
                break;
            fi;
        done;
        if [[ ${flag} -eq 1 ]]; then
            break;
        fi;
    done;
    if [[ ${flag} -eq 0 ]]; then
        for i in "$@";
        do
            msg=" ";
            for j in ${i};
            do
                msg+=" ${j} and";
            done;
            msg="${msg:0: -4} for ${desc}";
            elog "${msg}";
        done;
    fi
}
path_exists () 
{ 
    eerror "path_exists has been removed.  Please see the following post";
    eerror "for a replacement snippet:";
    eerror "https://blogs.gentoo.org/mgorny/2018/08/09/inlining-path_exists/";
    die "path_exists is banned"
}
pkg_nofetch () 
{ 
    default
}
preserve_old_lib () 
{ 
    if [[ ${EBUILD_PHASE} != "preinst" ]]; then
        eerror "preserve_old_lib() must be called from pkg_preinst() only";
        die "Invalid preserve_old_lib() usage";
    fi;
    [[ -z $1 ]] && die "Usage: preserve_old_lib <library to preserve> [more libraries to preserve]";
    has preserve-libs ${FEATURES} && return 0;
    has "${EAPI:-0}" 0 1 2 && local ED=${D} EROOT=${ROOT};
    local lib dir;
    for lib in "$@";
    do
        [[ -e ${EROOT}/${lib} ]] || continue;
        dir=${lib%/*};
        dodir ${dir} || die "dodir ${dir} failed";
        cp "${EROOT}"/${lib} "${ED}"/${lib} || die "cp ${lib} failed";
        touch "${ED}"/${lib};
    done
}
preserve_old_lib_notify () 
{ 
    if [[ ${EBUILD_PHASE} != "postinst" ]]; then
        eerror "preserve_old_lib_notify() must be called from pkg_postinst() only";
        die "Invalid preserve_old_lib_notify() usage";
    fi;
    has preserve-libs ${FEATURES} && return 0;
    has "${EAPI:-0}" 0 1 2 && local EROOT=${ROOT};
    local lib notice=0;
    for lib in "$@";
    do
        [[ -e ${EROOT}/${lib} ]] || continue;
        if [[ ${notice} -eq 0 ]]; then
            notice=1;
            ewarn "Old versions of installed libraries were detected on your system.";
            ewarn "In order to avoid breaking packages that depend on these old libs,";
            ewarn "the libraries are not being removed.  You need to run revdep-rebuild";
            ewarn "in order to remove these old dependencies.  If you do not have this";
            ewarn "helper program, simply emerge the 'gentoolkit' package.";
            ewarn;
        fi;
        ewarn "  # revdep-rebuild --library '${lib}' && rm '${lib}'";
    done
}
prune_libtool_files () 
{ 
    debug-print-function ${FUNCNAME} "$@";
    local removing_all removing_modules opt;
    for opt in "$@";
    do
        case "${opt}" in 
            --all)
                removing_all=1;
                removing_modules=1
            ;;
            --modules)
                removing_modules=1
            ;;
            *)
                die "Invalid argument to ${FUNCNAME}(): ${opt}"
            ;;
        esac;
    done;
    local f;
    local queue=();
    while IFS= read -r -d '' f; do
        local archivefile=${f/%.la/.a};
        if ! sed -n -e '/^# Generated by .*libtool/q0;4q1' "${f}"; then
            continue;
        fi;
        [[ ${f} != ${archivefile} ]] || die 'regex sanity check failed';
        local reason= pkgconfig_scanned=;
        local snotlink=$(sed -n -e 's:^shouldnotlink=::p' "${f}");
        if [[ ${snotlink} == yes ]]; then
            if [[ -f ${archivefile} ]]; then
                einfo "Removing unnecessary ${archivefile#${D%/}} (static plugin)";
                queue+=("${archivefile}");
            fi;
            if [[ -n ${removing_modules} ]]; then
                reason='module';
            fi;
        else
            if [[ -n ${removing_all} ]]; then
                reason='requested';
            else
                if [[ ! -f ${archivefile} ]]; then
                    reason='no static archive';
                else
                    if [[ ! -n $(sed -nre 					"s/^(dependency_libs|inherited_linker_flags)='(.*)'$/\2/p" 					"${f}") ]]; then
                        reason='no libs & flags';
                    else
                        if [[ ! -n ${pkgconfig_scanned} ]]; then
                            local pc_libs=();
                            if [[ ! -n ${removing_all} ]]; then
                                local pc;
                                local tf=${T}/prune-lt-files.pc;
                                local pkgconf=$(tc-getPKG_CONFIG);
                                while IFS= read -r -d '' pc; do
                                    local arg libs;
                                    if ${pkgconf} --exists "${pc}" &> /dev/null; then
                                        sed -e '/^Requires:/d' "${pc}" > "${tf}";
                                        libs=$(${pkgconf} --libs "${tf}");
                                    else
                                        libs=$(sed -ne 's/^Libs://p' "${pc}");
                                    fi;
                                    for arg in ${libs};
                                    do
                                        if [[ ${arg} == -l* ]]; then
                                            if [[ ${arg} == '*$*' ]]; then
                                                eerror "${FUNCNAME}: variable substitution likely failed in ${pc}";
                                                eerror "(arg: ${arg})";
                                                eerror "Most likely, you need to add virtual/pkgconfig to DEPEND.";
                                                die "${FUNCNAME}: unsubstituted variable found in .pc";
                                            fi;
                                            pc_libs+=(lib${arg#-l}.la);
                                        fi;
                                    done;
                                done < <(find "${D}" -type f -name '*.pc' -print0);
                                rm -f "${tf}";
                            fi;
                            pkgconfig_scanned=1;
                        fi;
                        has "${f##*/}" "${pc_libs[@]}" && reason='covered by .pc';
                    fi;
                fi;
            fi;
        fi;
        if [[ -n ${reason} ]]; then
            einfo "Removing unnecessary ${f#${D%/}} (${reason})";
            queue+=("${f}");
        fi;
    done < <(find "${D}" -xtype f -name '*.la' -print0);
    if [[ -n ${queue[@]} ]]; then
        rm -f "${queue[@]}";
    fi
}
run_in_build_dir () 
{ 
    debug-print-function ${FUNCNAME} "${@}";
    local ret;
    [[ ${#} -ne 0 ]] || die "${FUNCNAME}: no command specified.";
    [[ -n ${BUILD_DIR} ]] || die "${FUNCNAME}: BUILD_DIR not set.";
    mkdir -p "${BUILD_DIR}" || die;
    pushd "${BUILD_DIR}" > /dev/null || die;
    "${@}";
    ret=${?};
    popd > /dev/null || die;
    return ${ret}
}
src_compile () 
{ 
    autotools-multilib_src_compile "$@"
}
src_configure () 
{ 
    autotools-multilib_src_configure "$@"
}
src_install () 
{ 
    autotools-multilib_src_install "$@"
}
src_prepare () 
{ 
    autotools-multilib_src_prepare "$@"
}
src_test () 
{ 
    :
}
src_unpack () 
{ 
    default
}
strip-linguas () 
{ 
    local ls newls nols;
    if [[ $1 == "-i" ]] || [[ $1 == "-u" ]]; then
        local op=$1;
        shift;
        ls=$(find "$1" -name '*.po' -exec basename {} .po ';');
        shift;
        local d f;
        for d in "$@";
        do
            if [[ ${op} == "-u" ]]; then
                newls=${ls};
            else
                newls="";
            fi;
            for f in $(find "$d" -name '*.po' -exec basename {} .po ';');
            do
                if [[ ${op} == "-i" ]]; then
                    has ${f} ${ls} && newls="${newls} ${f}";
                else
                    has ${f} ${ls} || newls="${newls} ${f}";
                fi;
            done;
            ls=${newls};
        done;
    else
        ls="$@";
    fi;
    nols="";
    newls="";
    for f in ${LINGUAS};
    do
        if has ${f} ${ls}; then
            newls="${newls} ${f}";
        else
            nols="${nols} ${f}";
        fi;
    done;
    [[ -n ${nols} ]] && einfo "Sorry, but ${PN} does not support the LINGUAS:" ${nols};
    export LINGUAS=${newls:1}
}
tc-arch () 
{ 
    tc-ninja_magic_to_arch portage "$@"
}
tc-arch-kernel () 
{ 
    tc-ninja_magic_to_arch kern "$@"
}
tc-check-openmp () 
{ 
    if ! tc-has-openmp; then
        eerror "Your current compiler does not support OpenMP!";
        if tc-is-gcc; then
            eerror "Enable OpenMP support by building sys-devel/gcc with USE=\"openmp\".";
        else
            if tc-is-clang; then
                eerror "OpenMP support in sys-devel/clang is provided by sys-libs/libomp.";
            fi;
        fi;
        die "Active compiler does not have required support for OpenMP";
    fi
}
tc-cpp-is-true () 
{ 
    local CONDITION=${1};
    shift;
    local RESULT=$($(tc-getTARGET_CPP) "${@}" -P - <<-EOF 2>/dev/null
			#if ${CONDITION}
			true
			#endif
		EOF
	);
    [[ ${RESULT} == true ]]
}
tc-detect-is-softfloat () 
{ 
    [[ $(tc-getTARGET_CPP) == "gcc -E" ]] && return 1;
    case ${CTARGET:-${CHOST}} in 
        *-newlib | *-elf | *-eabi)
            return 1
        ;;
        arm*)
            if tc-cpp-is-true "defined(__ARM_PCS_VFP)"; then
                echo "no";
            else
                if tc-cpp-is-true "defined(__SOFTFP__)"; then
                    echo "yes";
                else
                    echo "softfp";
                fi;
            fi;
            return 0
        ;;
        *)
            return 1
        ;;
    esac
}
tc-enables-pie () 
{ 
    tc-cpp-is-true "defined(__PIE__)" ${CPPFLAGS} ${CFLAGS}
}
tc-enables-ssp () 
{ 
    tc-cpp-is-true "defined(__SSP__) || defined(__SSP_STRONG__) || defined(__SSP_ALL__)" ${CPPFLAGS} ${CFLAGS}
}
tc-enables-ssp-all () 
{ 
    tc-cpp-is-true "defined(__SSP_ALL__)" ${CPPFLAGS} ${CFLAGS}
}
tc-enables-ssp-strong () 
{ 
    tc-cpp-is-true "defined(__SSP_STRONG__) || defined(__SSP_ALL__)" ${CPPFLAGS} ${CFLAGS}
}
tc-endian () 
{ 
    local host=$1;
    [[ -z ${host} ]] && host=${CTARGET:-${CHOST}};
    host=${host%%-*};
    case ${host} in 
        aarch64*be)
            echo big
        ;;
        aarch64)
            echo little
        ;;
        alpha*)
            echo little
        ;;
        arm*b*)
            echo big
        ;;
        arm*)
            echo little
        ;;
        cris*)
            echo little
        ;;
        hppa*)
            echo big
        ;;
        i?86*)
            echo little
        ;;
        ia64*)
            echo little
        ;;
        m68*)
            echo big
        ;;
        mips*l*)
            echo little
        ;;
        mips*)
            echo big
        ;;
        powerpc*le)
            echo little
        ;;
        powerpc*)
            echo big
        ;;
        riscv*)
            echo little
        ;;
        s390*)
            echo big
        ;;
        sh*b*)
            echo big
        ;;
        sh*)
            echo little
        ;;
        sparc*)
            echo big
        ;;
        x86_64*)
            echo little
        ;;
        *)
            echo wtf
        ;;
    esac
}
tc-env_build () 
{ 
    tc-export_build_env;
    CFLAGS=${BUILD_CFLAGS} CXXFLAGS=${BUILD_CXXFLAGS} CPPFLAGS=${BUILD_CPPFLAGS} LDFLAGS=${BUILD_LDFLAGS} AR=$(tc-getBUILD_AR) AS=$(tc-getBUILD_AS) CC=$(tc-getBUILD_CC) CPP=$(tc-getBUILD_CPP) CXX=$(tc-getBUILD_CXX) LD=$(tc-getBUILD_LD) NM=$(tc-getBUILD_NM) PKG_CONFIG=$(tc-getBUILD_PKG_CONFIG) RANLIB=$(tc-getBUILD_RANLIB) "$@"
}
tc-export () 
{ 
    local var;
    for var in "$@";
    do
        [[ $(type -t "tc-get${var}") != "function" ]] && die "tc-export: invalid export variable '${var}'";
        "tc-get${var}" > /dev/null;
    done
}
tc-export_build_env () 
{ 
    tc-export "$@";
    if tc-is-cross-compiler; then
        : ${BUILD_CFLAGS:=-O1 -pipe};
        : ${BUILD_CXXFLAGS:=-O1 -pipe};
        : ${BUILD_CPPFLAGS:= };
        : ${BUILD_LDFLAGS:= };
    else
        : ${BUILD_CFLAGS:=${CFLAGS}};
        : ${BUILD_CXXFLAGS:=${CXXFLAGS}};
        : ${BUILD_CPPFLAGS:=${CPPFLAGS}};
        : ${BUILD_LDFLAGS:=${LDFLAGS}};
    fi;
    export BUILD_{C,CXX,CPP,LD}FLAGS;
    local v;
    for v in BUILD_{C,CXX,CPP,LD}FLAGS;
    do
        export ${v#BUILD_}_FOR_BUILD="${!v}";
    done
}
tc-get-compiler-type () 
{ 
    local code='
#if defined(__PATHSCALE__)
	HAVE_PATHCC
#elif defined(__clang__)
	HAVE_CLANG
#elif defined(__GNUC__)
	HAVE_GCC
#endif
';
    local res=$($(tc-getCPP "$@") -E -P - <<<"${code}");
    case ${res} in 
        *HAVE_PATHCC*)
            echo pathcc
        ;;
        *HAVE_CLANG*)
            echo clang
        ;;
        *HAVE_GCC*)
            echo gcc
        ;;
        *)
            echo unknown
        ;;
    esac
}
tc-getAR () 
{ 
    tc-getPROG AR ar "$@"
}
tc-getAS () 
{ 
    tc-getPROG AS as "$@"
}
tc-getBUILD_AR () 
{ 
    tc-getBUILD_PROG AR ar "$@"
}
tc-getBUILD_AS () 
{ 
    tc-getBUILD_PROG AS as "$@"
}
tc-getBUILD_CC () 
{ 
    tc-getBUILD_PROG CC gcc "$@"
}
tc-getBUILD_CPP () 
{ 
    tc-getBUILD_PROG CPP "$(tc-getBUILD_CC) -E" "$@"
}
tc-getBUILD_CXX () 
{ 
    tc-getBUILD_PROG CXX g++ "$@"
}
tc-getBUILD_LD () 
{ 
    tc-getBUILD_PROG LD ld "$@"
}
tc-getBUILD_NM () 
{ 
    tc-getBUILD_PROG NM nm "$@"
}
tc-getBUILD_OBJCOPY () 
{ 
    tc-getBUILD_PROG OBJCOPY objcopy "$@"
}
tc-getBUILD_PKG_CONFIG () 
{ 
    tc-getBUILD_PROG PKG_CONFIG pkg-config "$@"
}
tc-getBUILD_PROG () 
{ 
    local vars="BUILD_$1 $1_FOR_BUILD HOST$1";
    tc-is-cross-compiler || vars+=" $1";
    _tc-getPROG CBUILD "${vars}" "${@:2}"
}
tc-getBUILD_RANLIB () 
{ 
    tc-getBUILD_PROG RANLIB ranlib "$@"
}
tc-getBUILD_STRIP () 
{ 
    tc-getBUILD_PROG STRIP strip "$@"
}
tc-getCC () 
{ 
    tc-getPROG CC gcc "$@"
}
tc-getCPP () 
{ 
    tc-getPROG CPP "${CC:-gcc} -E" "$@"
}
tc-getCXX () 
{ 
    tc-getPROG CXX g++ "$@"
}
tc-getDLLWRAP () 
{ 
    tc-getPROG DLLWRAP dllwrap "$@"
}
tc-getF77 () 
{ 
    tc-getPROG F77 gfortran "$@"
}
tc-getFC () 
{ 
    tc-getPROG FC gfortran "$@"
}
tc-getGCJ () 
{ 
    tc-getPROG GCJ gcj "$@"
}
tc-getGO () 
{ 
    tc-getPROG GO gccgo "$@"
}
tc-getLD () 
{ 
    tc-getPROG LD ld "$@"
}
tc-getNM () 
{ 
    tc-getPROG NM nm "$@"
}
tc-getOBJCOPY () 
{ 
    tc-getPROG OBJCOPY objcopy "$@"
}
tc-getOBJDUMP () 
{ 
    tc-getPROG OBJDUMP objdump "$@"
}
tc-getPKG_CONFIG () 
{ 
    tc-getPROG PKG_CONFIG pkg-config "$@"
}
tc-getPROG () 
{ 
    _tc-getPROG CHOST "$@"
}
tc-getRANLIB () 
{ 
    tc-getPROG RANLIB ranlib "$@"
}
tc-getRC () 
{ 
    tc-getPROG RC windres "$@"
}
tc-getSTRIP () 
{ 
    tc-getPROG STRIP strip "$@"
}
tc-getTARGET_CPP () 
{ 
    if [[ -n ${CTARGET} ]]; then
        _tc-getPROG CTARGET TARGET_CPP "gcc -E" "$@";
    else
        tc-getCPP "$@";
    fi
}
tc-has-openmp () 
{ 
    local base="${T}/test-tc-openmp";
    cat <<-EOF > "${base}.c"
#include <omp.h>
int main() {
int nthreads, tid, ret = 0;
#pragma omp parallel private(nthreads, tid)
{
tid = omp_get_thread_num();
nthreads = omp_get_num_threads(); ret += tid + nthreads;
}
return ret;
}
EOF

    $(tc-getCC "$@") -fopenmp "${base}.c" -o "${base}" &> /dev/null;
    local ret=$?;
    rm -f "${base}"*;
    return ${ret}
}
tc-has-tls () 
{ 
    local base="${T}/test-tc-tls";
    cat <<-EOF > "${base}.c"
int foo(int *i) {
static __thread int j = 0;
return *i ? j : *i;
}
EOF

    local flags;
    case $1 in 
        -s)
            flags="-S"
        ;;
        -c)
            flags="-c"
        ;;
        -l)

        ;;
        -*)
            die "Usage: tc-has-tls [-c|-l] [toolchain prefix]"
        ;;
    esac;
    : ${flags:=-fPIC -shared -Wl,-z,defs};
    [[ $1 == -* ]] && shift;
    $(tc-getCC "$@") ${flags} "${base}.c" -o "${base}" &> /dev/null;
    local ret=$?;
    rm -f "${base}"*;
    return ${ret}
}
tc-is-clang () 
{ 
    [[ $(tc-get-compiler-type) == clang ]]
}
tc-is-cross-compiler () 
{ 
    [[ ${CBUILD:-${CHOST}} != ${CHOST} ]]
}
tc-is-gcc () 
{ 
    [[ $(tc-get-compiler-type) == gcc ]]
}
tc-is-softfloat () 
{ 
    tc-detect-is-softfloat || tc-tuple-is-softfloat
}
tc-is-static-only () 
{ 
    local host=${CTARGET:-${CHOST}};
    [[ ${host} == *-mint* ]]
}
tc-ld-disable-gold () 
{ 
    if ! tc-ld-is-gold "$@"; then
        return;
    fi;
    ewarn "Forcing usage of the BFD linker instead of GOLD";
    local ld=$(tc-getLD "$@");
    local bfd_ld="${ld%% *}.bfd";
    local path_ld=$(which "${bfd_ld}" 2>/dev/null);
    [[ -e ${path_ld} ]] && export LD=${bfd_ld};
    local fallback="true";
    if tc-is-gcc; then
        local major=$(gcc-major-version "$@");
        local minor=$(gcc-minor-version "$@");
        if [[ ${major} -gt 4 ]] || [[ ${major} -eq 4 && ${minor} -ge 8 ]]; then
            export LDFLAGS="${LDFLAGS} -fuse-ld=bfd";
            fallback="false";
        fi;
    else
        if tc-is-clang; then
            local major=$(clang-major-version "$@");
            local minor=$(clang-minor-version "$@");
            if [[ ${major} -gt 3 ]] || [[ ${major} -eq 3 && ${minor} -ge 5 ]]; then
                export LDFLAGS="${LDFLAGS} -fuse-ld=bfd";
                fallback="false";
            fi;
        fi;
    fi;
    if [[ ${fallback} == "true" ]]; then
        if [[ -e ${path_ld} ]]; then
            local d="${T}/bfd-linker";
            mkdir -p "${d}";
            ln -sf "${path_ld}" "${d}"/ld;
            export LDFLAGS="${LDFLAGS} -B${d}";
        else
            die "unable to locate a BFD linker to bypass gold";
        fi;
    fi
}
tc-ld-is-gold () 
{ 
    local out;
    out=$($(tc-getLD "$@") --version 2>&1);
    if [[ ${out} == *"GNU gold"* ]]; then
        return 0;
    fi;
    local base="${T}/test-tc-gold";
    cat <<-EOF > "${base}.c"
int main() { return 0; }
EOF

    out=$($(tc-getCC "$@") ${CFLAGS} ${CPPFLAGS} ${LDFLAGS} -Wl,--version "${base}.c" -o "${base}" 2>&1);
    rm -f "${base}"*;
    if [[ ${out} == *"GNU gold"* ]]; then
        return 0;
    fi;
    return 1
}
tc-ninja_magic_to_arch () 
{ 
    function ninj () 
    { 
        [[ ${type} == "kern" ]] && echo $1 || echo $2
    };
    local type=$1;
    local host=$2;
    [[ -z ${host} ]] && host=${CTARGET:-${CHOST}};
    case ${host} in 
        aarch64*)
            echo arm64
        ;;
        alpha*)
            echo alpha
        ;;
        arm*)
            echo arm
        ;;
        avr*)
            ninj avr32 avr
        ;;
        bfin*)
            ninj blackfin bfin
        ;;
        c6x*)
            echo c6x
        ;;
        cris*)
            echo cris
        ;;
        frv*)
            echo frv
        ;;
        hexagon*)
            echo hexagon
        ;;
        hppa*)
            ninj parisc hppa
        ;;
        i?86*)
            if [[ ${type} == "kern" && ${host} == *freebsd* ]]; then
                echo i386;
            else
                echo x86;
            fi
        ;;
        ia64*)
            echo ia64
        ;;
        m68*)
            echo m68k
        ;;
        metag*)
            echo metag
        ;;
        microblaze*)
            echo microblaze
        ;;
        mips*)
            echo mips
        ;;
        nios2*)
            echo nios2
        ;;
        nios*)
            echo nios
        ;;
        or1k | or32*)
            echo openrisc
        ;;
        powerpc*)
            if [[ ${type} == "kern" ]]; then
                echo powerpc;
            else
                if [[ ${host} == powerpc64* ]]; then
                    echo ppc64;
                else
                    echo ppc;
                fi;
            fi
        ;;
        riscv*)
            echo riscv
        ;;
        s390*)
            echo s390
        ;;
        score*)
            echo score
        ;;
        sh64*)
            ninj sh64 sh
        ;;
        sh*)
            echo sh
        ;;
        sparc64*)
            ninj sparc64 sparc
        ;;
        sparc*)
            [[ ${PROFILE_ARCH} == "sparc64" ]] && ninj sparc64 sparc || echo sparc
        ;;
        tile*)
            echo tile
        ;;
        vax*)
            echo vax
        ;;
        x86_64*freebsd*)
            echo amd64
        ;;
        x86_64*)
            if [[ ${type} == "kern" ]]; then
                echo x86;
            else
                echo amd64;
            fi
        ;;
        xtensa*)
            echo xtensa
        ;;
        *)
            echo unknown
        ;;
    esac
}
tc-stack-grows-down () 
{ 
    case ${ARCH} in 
        hppa | metag)
            return 1
        ;;
    esac;
    return 0
}
tc-tuple-is-softfloat () 
{ 
    local CTARGET=${CTARGET:-${CHOST}};
    case ${CTARGET//_/-} in 
        bfin* | h8300*)
            echo "only"
        ;;
        *-softfloat-*)
            echo "yes"
        ;;
        *-softfp-*)
            echo "softfp"
        ;;
        arm*-hardfloat-* | arm*eabihf)
            echo "no"
        ;;
        *-newlib | *-elf | *-eabi)
            echo "no"
        ;;
        arm*)
            echo "yes"
        ;;
        *)
            echo "no"
        ;;
    esac
}
uclibctoolize () 
{ 
    die "Use elibtoolize"
}
use_if_iuse () 
{ 
    in_iuse $1 || return 1;
    use $1
}
